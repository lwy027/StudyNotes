## 操作系统

> by九牧

## 第 1 章 计算机系统概述

### 1.1 操作系统的基本概念

#### 1.1.1 操作系统的概念、功能和目标

> 系统资源的管理者、提供接口、作为扩充机器、虚拟机

##### 1.1.1.1 熟悉的操作系统举例

![](https://img-blog.csdnimg.cn/2020022012313767.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 1.1.1.2 操作系统的层次结构

![](https://img-blog.csdnimg.cn/20200220125305234.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 1.1.1.3 操作系统的概念

- 是系统最基本、最核心的`软件`，属于`系统软件`
- 控制和管理整个计算机的硬件和软件资源
- 合理的组织、调度计算机的工作与资源的分配
- 为用户和其它软件提供方便的接口和环境

![](https://img-blog.csdnimg.cn/20200220130754779.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 1.1.1.4 操作系统的功能和目标

![](https://img-blog.csdnimg.cn/20200220181209621.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

- 用一个直观的例子来理解上述图中操作系统的功能：

>- 我们假设：用户是雇主，操作系统是工人（用来操作机器），计算机是机器（由处理机(CPU)、存储器、设备、文件几个部件构成）
>- 工人有熟练的技能去控制和协调各个部件的工作，这就是操作系统对资源的管理
>- 同时，工人必须接受雇主的命令，这就是“接口”
>- 有了工人，机器就能发挥更大的作用，因此工人就成了“扩充机器”
>- 工人操作机器、机器有了更大的作用比如GUI界面，于是工人便成了扩充机器，去扩充GUI界面等功能

###### （1）作为计算机系统资源的管理者

- 管理软硬件资源、合理的组织、调度计算机的工作与资源的分配

 ![](https://img-blog.csdnimg.cn/20200220175206746.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

1️⃣处理器（CPU）管理

- 在多道程序环境下，cpu的分配和运行都以进程（或线程）为基本单位，因此对cpu的管理可理解为对进程的管理。进程管理的主要功能包括`进程控制、进程同步、进程通信、死锁处理、处理机调度`等。附上一张图理解对进程的管理。

![](https://img-blog.csdnimg.cn/20200220174054546.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

2️⃣存储器管理

- 为多道程序的运行提供良好的环境，方便用户使用及提高内存的利用率，主要包括`内存分配与回收、地址映射、内存保护与共享和内存扩充`等功能。

![](https://img-blog.csdnimg.cn/20200220174345586.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

3️⃣文件管理

- 计算机中所有的信息都是以文件的形式存在的，操作系统中负责文件的管理的部分称为文件系统，文件管理包括`文件存储空间的管理、目录管理及文件读写管理和保护`等。

![](https://img-blog.csdnimg.cn/20200220175651564.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

4️⃣设备管理

- 设备管理的主要任务是完成用户的I/O请求，方便用户使用各种设备，并提高设备的利用率，主要`包括缓存管理、设备分配、设备处理和虚拟设备`等功能。

![](https://img-blog.csdnimg.cn/20200220180110573.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

> 以上4种管理功能都由“工人”负责，“雇主”无序关注。

###### （2）作为用户与计算机硬件系统之间的接口

- 为了让用户方便、快捷、可靠的操作计算机硬件并执行自己的程序，操作系统提供了用户接口
- 操作系统提供的接口分为两类：`命令接口和程序接口`
- `命令接口`：用户可以`直接`使用的，利用这些操作命令来组织和控制作业的执行
- `程序接口`：用户通过程序`间接`使用的，编程人员可以使用它们来请求操作系统服务

 ![](https://img-blog.csdnimg.cn/20200220181548282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

1️⃣命令接口

- 命令接口分为两类：联机命令接口和脱机命令接口，用户可以`直接`调用
- `联机命令接口`：又称交互式命令接口，适用于分时或实时系统的接口，由一组键盘操作命令组成。用户输入一条指令，操作系统就执行一条指令；

![](https://img-blog.csdnimg.cn/20200220182355987.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

- `脱机命令接口`：又称批处理接口，使用于批处理系统，由一组作业控制命令组成。用户输入一堆指令，操作系统运行一堆指令。在操作系统运行这些命令时用户不可干预。

> 批处理(Batch)，也称为批处理脚本。顾名思义，批处理就是对某对象进行批量的处理，通常被认为是一种简化的脚本语言，它应用于DOS和Windows系统中。批处理文件的扩展名为bat 。
>
> ![](https://img-blog.csdnimg.cn/20200220182828410.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

2️⃣程序接口

- 程序接口：由一组`系统调用（也称广义指令）`组成
- 用户通过在程序中使用这些系统调用来请求操作系统为其提供服务，只能通过用户程序`间接`调用
- 如使用各种外部设备、申请分配和回收内存及其它各种要求

![](https://img-blog.csdnimg.cn/2020022018383578.png)

> 动态链接库英文为DLL，是Dynamic Link Library的缩写。DLL是一个包含可由多个程序，同时使用的代码和数据的库。

- 比如常见的图形用户界面程序接口GUI

![](https://img-blog.csdnimg.cn/20200220184655178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

 ![](https://img-blog.csdnimg.cn/20200220184339565.png)

###### （3）作为扩充机器（[虚拟机](https://so.csdn.net/so/search?q=虚拟机&spm=1001.2101.3001.7020)）

 ![](https://img-blog.csdnimg.cn/20200220184843350.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

- 没有任何软件支持的计算机称为`裸机`
- 覆盖了软件的机器称为`扩充机器或虚拟机`

![](https://img-blog.csdnimg.cn/20200220185203629.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

#### 1.1.2 操作系统的特征（并发、共享、虚拟、异步）

- 操作系统是一种系统软件，但与其它系统软件和应用软件有很大的不同，它有自己的特殊性及基本特征。

##### 1.1.2.1 总览

![](https://img-blog.csdnimg.cn/20200220220130442.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 1.1.2.2 [并发](https://so.csdn.net/so/search?q=并发&spm=1001.2101.3001.7020)

- `并发`：两个或多个事件在`同一时间`间隔内发生，这些事件在宏观上是同时发生的，在微观上是交替发生的， 操作系统的并发性指系统中同时存在着多个运行的程序
- `并行`：两个或多个事件在`同一时刻`发生
- 一个单核（CPU）同一时刻只能执行一个程序，因此操作系统会协调多个程序使他们交替进行（这些程序在宏观上是同时发生的，在微观上是交替进行的）
- 操作系统是伴随着“多道程序技术出现的”，因此操作系统和并发是一同诞生的
- 在如今的计算机中，一般都是多核cpu的，即在`同一时刻`可以并行执行多个程序，比如我的计算机是8核的，我的计算机可以在同一时刻并行执行8个程序，但是事实上我们计算机执行的程序并不止8个，因此并发技术是必须存在的，**并发性必不可少**

 ![](https://img-blog.csdnimg.cn/20200220201755124.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 1.1.2.3 共享

- `资源共享`即共享，是指系统中的资源可以`供内存中多个并发执行的进程`共同使用
- 共享分为两类：互斥共享和同时共享

###### （1）互斥共享

- 计算机中的某个资源在一段时间内只能允许`一个进程`访问，别的进程没有使用权
- 临界资源（独占资源）：在一段时间内只允许一个进程访问的资源，计算机中大多数物理设备及某些软件中的栈、变量和表格都属于临界资源，它们被要求互斥共享
- 举个例子：比如QQ和微信视频，同一段时间内摄像头只能分配给其中一个进程

###### （2）同时共享

- 计算机中的某个资源在一段时间内可以`同时`允许`多个`进程访问
- 同时共享通常要求一个请求分为几个时间片段间隔的完成，即交替进行，“分时共享”
- 这里的`同时`指在宏观上是同时的，在微观上是交替进行访问的，只是cpu处理速度很快，我们感觉不到，在宏观上感觉是在同时进行
- 举个例子：比如QQ在发送文件A，微信在发送文件B，宏观上两个进程A和B都在访问磁盘，在我们看来是同时进行的，但是在微观上两个进程A和B是交替进行访问磁盘的，只是时间太短，cpu处理速度太快，我们感觉不到。
- `注意`：有时候多个进程可能真的是在同时进行资源访问，比如玩游戏时可以放音乐，游戏声音和音乐声音都能听见

###### （3）并发性和共享性互为存在条件

![](https://img-blog.csdnimg.cn/20200220204551232.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 1.1.2.4 虚拟

> 多道程序设计：是指在计算机内存中同时存放几道相互独立的程序，使它们在管理程序控制之下，相互穿插的运行。 两个或两个以上程序在计算机系统中同处于开始到结束之间的状态。这就称为多道程序设计。多道程序技术运行的特征：多道、宏观上并行、微观上串行。

- 虚拟是把一个物理上的实体变为若干逻辑上的对应物。
- 物理实体（前者）是实际存在的；而后者是虚的，是用户感觉上的事务
- 虚拟技术：用于实现虚拟的技术
- 虚拟处理器（CPU）：通过多道程序设计技术，采用让多道程序并发执行的方法，分时来使用一个CPU，实际物理上只有一个CPU，但是用户感觉到有多个CPU
- 虚拟存储器：从逻辑上扩充存储器容量，用户感觉到的但实际不存在的存储器
- 虚拟设备：将一台物理设备虚拟为逻辑上的多台设备，使多个用户在同一时间段内访问同一台设备，即同时共享，用户宏观上感觉是同时的，但实际上是微观交替访问同一台设备的
- 操作系统的虚拟技术科归纳为：
  - 时分复用技术：如处理器的分时共享
  - 空间复用技术：如虚拟存储器

![](https://img-blog.csdnimg.cn/20200220215401443.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 1.1.2.5 异步

异步：多道程序环境允许多个程序并发执行，但由于资源有限，如cpu只有一个，进程的执行并不是一贯到底的，而是走走停停的，它以不可预知的速度向前推进。

> 比如A进程正在占用CPU计算，B进程这时也想占用CPU计算，B进程只有等，等A进程算完了，A进程去访问磁盘资源了，这时B进程再占用CPU进行计算，B进程还没计算完，A进程从磁盘取出资源了，A进程发现B这时在占用CPU，这时A进程就需要等待，等B算完后再继续到CPU中进行计算。由于每个进程占用资源的时间不固定，所以进程的执行以不可预知的速度前进

#### 习题

### 1.2 操作系统的发展和分类

> 手工、单道/多道批处理、分时、实时、网络、分布式、嵌入式、个人计算机

#### 1.2.1 操作系统的分类及其特征优劣

![](https://img-blog.csdnimg.cn/20200222160313682.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

#### 1.2.2 操作系统的发展历程

![](https://img-blog.csdnimg.cn/20200222161909768.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

#### 习题

### 1.3 操作系统的运行机制和体系结构

#### 1.3.1 操作系统的运行机制和体系结构（大内核、小内核）

##### 1.3.1.1 操作系统的运行机制和[体系结构](https://so.csdn.net/so/search?q=体系结构&spm=1001.2101.3001.7020)

![](https://img-blog.csdnimg.cn/2020022223135066.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 1.3.1.2 操作系统内核在计算机系统中的层次结构

![](https://img-blog.csdnimg.cn/20200222231536872.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 1.3.1.3 操作系统体系结构类比

管态：特权态、系统态、内核态或者核心态

目态：用户态、普通态

![](https://img-blog.csdnimg.cn/20200222231654803.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 1.3.1.4 操作系统用户态和核心态的转换

 ![](https://img-blog.csdnimg.cn/20200223155949457.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

#### 1.3.2 中断和异常（内中断和外中断、中断处理过程）

![](https://img-blog.csdnimg.cn/20200223165736223.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

#### 1.3.3 系统调用（执行过程、访管指令、库函数与系统调用）

##### 1.3.3.1 总览

![](https://img-blog.csdnimg.cn/20200223183347138.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 1.3.3.2 系统调用和[库函数](https://so.csdn.net/so/search?q=库函数&spm=1001.2101.3001.7020)的区别

![](https://img-blog.csdnimg.cn/20200223182336630.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 1.3.3.3 系统调用的执行过程

![](https://img-blog.csdnimg.cn/20200223182805329.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

#### 习题

## 第 2 章 进程管理

### 2.1 进程与线程

#### 2.1.1 进程的定义、特征、组成、组织

##### 2.1.1.1 总览

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1273/image-20220419131146074.png)

##### 2.1.1.2 进程的定义

###### （1）程序的概念

[程序](https://baike.baidu.com/item/%E7%A8%8B%E5%BA%8F/13831935)：一组计算机能识别和执行的指令。

> 是静态的，就是个存放在磁盘里的**可执行文件**，如：QQ.exe。

早期的计算机只支持**单道**程序：

![](https://img-blog.csdnimg.cn/20200309182108942.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

###### （2）进程的概念

>是动态的，是**程序的一次执行过程**，如：可同时启动多次QQ程序

![](https://img-blog.csdnimg.cn/20200309182335281.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

- 进程和程序的区别和联系：

  > 区别：
  >
  > 1、进程是动态的，程序是静态的
  >
  > 2、进程有独立性，能并发执行；程序不能并发执行
  >
  > 3、二者无一一对应关系
  >
  > 4、进程异步运行，会相互制约；程序不具备此特征
  >
  > 但是，进程与程序又有密切的联系： 进程不能脱离具体程序而虚设， 程序规定了相应进程所要完成的动作
  >
  > 5、组成不同。进程包含PCB、程序段、数据段。程序包含数据和指令代码
  >
  > 6、程序是一个包含了所有指令和数据的静态实体。本身除占用磁盘的存储空间外，并不占用系统如CPU、内存等运行资源
  >
  > 7、进程由程序段、数据段和PCB构成，会占用系统如CPU、内存等运行资源
  >
  > 8、一个程序可以启动多个进程来共同完成
  >
  > 联系：
  >
  > 1、进程不能脱离具体程序而虚设， 程序规定了相应进程所要完成的动作
  >
  > 2、同一个程序多次执行会对应多个进程

###### （3）进程的定义

![](https://img-blog.csdnimg.cn/202003091827285.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 2.1.1.3 进程的特征

![](https://img-blog.csdnimg.cn/20200309183218935.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

>异步性会导致并发程序执行结果的不确定性

##### 2.1.1.4 进程的组成

###### （1）总览

- 程序段、数据段、🥇PCB

![](https://img-blog.csdnimg.cn/20200309183432616.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

> 其中最主要的就是`进程控制块PCB`（Process Control Block）

🤔操作系统是这些进程的管理者，它要怎么区分各个进程？🧐

> 当进程被创建时，操作系统会为该进程分配一个唯一的、不重复的“身份证号”—— PID（Process ID，进程ID）

- 操作系统要记录PID、进程所属用户ID（UID）

  >基本的进程描述信息，可以让操作系统区分各个进程

- 还要记录给进程分配了哪些资源（如：分配了多少内存、正在使用哪些I/O设备、正在使用哪些文件）

  >可用于实现操作系统对资源的管理

- 还要记录进程的运行情况（如：CPU使用时间、磁盘使用情况、网络流量使用情况等）

  >可用于实现操作系统对进程的控制、调度

这些信息都被保存在一个数据结构PCB（Process Control Block）中，即`进程控制块`

操作系统需要对各个并发运行的进程进行管理，但凡管理时所需要的信息，都会被放在PCB中

###### （2）PCB

**[PCB简介](https://baike.baidu.com/item/PCB/16067368)：**

☀PCB中记录了操作系统所需的，用于描述进程的当前情况以及控制进程运行的全部信息。

PCB的作用是使一个在多道程序环境下不能独立运行的程序（含数据），成为一个能独立运行的基本单位，一个能与其他进程并发执行的进程。

或者说，**OS是根据PCB来对并发执行的进程进行控制和管理的**。

例如，当OS要**调度**某进程执行时，要从该进程的PCB中查处其现行状态及优先级；在调度到某进程后，要根据其PCB中所保存的处理机状态信息，设置该进程恢复运行的现场，并根据其PCB中的程序和数据的内存始址，找到其程序和数据；

进程在**执行**过程中，当需要和与之合作的进程实现同步，通信或者访问文件时，也都需要访问PCB；

当进程由于某种原因而**暂停**执行时，又须将器断点的处理机环境保存在PCB中。

可见，在进程的整个生命期中，系统总是通过PCB对进程进行控制的，即系统是根据进程的PCB而不是任何别的什么而感知到该进程的存在的。

所以说，PCB是进程存在的唯一标志。



- PCB通常包含的内容：

  >PCB是进程存在的唯一标志，当进程被创建时，操作系统为其创建PCB，当进程结束时，会回收其PCB。
  >
  >操作系统对进程进行管理工作所需的信息都存在PCB中

![](https://img-blog.csdnimg.cn/20200309191134423.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

###### （3）程序段、数据段

- PCB 是给**操作系统**用的
- 程序段、数据段是给**进程**自己用的

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1273/image-20220419131011999.png)

##### 2.1.1.5 进程的组织

![](https://img-blog.csdnimg.cn/20200309193130163.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

###### （1）链接方式

>多核CPU可有多个进程同时处于运行态

![](https://img-blog.csdnimg.cn/20200309193418616.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

>很多操作系统还会根据阻塞原因不同，再分为多个阻塞队列

###### （2）[索引](https://so.csdn.net/so/search?q=索引&spm=1001.2101.3001.7020)方式

![](https://img-blog.csdnimg.cn/20200309193441596.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

#### 2.1.2 进程的状态及转换

[状态](https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81/7387758)：运行、就绪、阻塞、创建、终止

[转换](https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81/7387758)：就绪——>运行、运行——>就绪、运行——>阻塞、阻塞——>就绪

##### 2.1.2.1 总图

![](https://img-blog.csdnimg.cn/20200312150009336.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 2.1.2.2 进程的状态

> 进程PCB中，会有一个变量 state 来表示进程的当前状态。如：1表示创建态、2表示就绪态、3表示运行态…
>
> 为了对同一个状态下的各个进程进行统一的管理，操作系统会将各个进程的PCB组织起来。

###### （1）三种基本状态（就绪、运行、阻塞）

![](https://img-blog.csdnimg.cn/20200312150211499.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

###### （2）创建态和结束态

![](https://img-blog.csdnimg.cn/20200312151550697.png)

- 创建态

  ![](https://img-blog.csdnimg.cn/20200312151018320.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

- 结束态

  ![](https://img-blog.csdnimg.cn/20200312151509374.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 2.1.2.3 进程状态的转换

- 进程一共有如下5种状态，那么他们之间如何实现切换呢？

![](https://img-blog.csdnimg.cn/20200312151835400.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)



- 咱们从一个进程的从无到有看起，来了解进程5种状态之间的转换

  >（1）运行态一一等待态：等待使用资源或某事件发生，如等待外设传输、等待人工干预。
  >
  >（2）等待态一一就绪态：资源得到满足或某事件己经发生，如外设传输结束、人工干预完成。
  >
  >（3）运行态一一就绪态：运行时间片到，或出现有更高优先级进程。
  >
  >（4）就绪态一一运行态：CPU空闲时被调度选中一个就绪进程执行。

  ![](https://img-blog.csdnimg.cn/20200312152430501.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1273/image-20220419132027199.png)

- 来一张形象生动的图片感受一下5种状态之间的切换

  ![](https://img-blog.csdnimg.cn/20200312152541970.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

#### 2.1.3 原语实现对进程的控制

##### 2.1.3.1 总图

![](https://img-blog.csdnimg.cn/20200315161517443.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 2.1.3.2 什么是进程控制？

![](https://img-blog.csdnimg.cn/20200315162852396.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 2.1.3.3 原语实现对进程的控制

![](https://img-blog.csdnimg.cn/20200315162921767.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 2.1.3.4 回忆进程的组织

- 进程在操作系统中的组织使各个进程能够有序的进行切换和运行

  ![](https://img-blog.csdnimg.cn/20200315161840214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 2.1.3.5 进程控制大致图解

![](https://img-blog.csdnimg.cn/20200315162618731.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

> 这里说明一下调度和切换的区别：
>
> `调度`是指决定资源分配给哪个进程的行为，是一种决策行为
>
> `切换`是指实际分配的行为，是执行行为
>
> 一般来说先有资源调度，后有进程切换

##### 2.1.3.6 进程控制原语的相同点

![](https://img-blog.csdnimg.cn/20200315163214185.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

- 接下来我们就具体学习一下关于进程控制的五种原语，`进程的创建、终止、唤醒、阻塞、切换；`

##### 2.1.3.7 进程控制的五种原语

###### （1）进程的创建原语

![](https://img-blog.csdnimg.cn/20200315163724449.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

###### （2）进程的终止原语

![](https://img-blog.csdnimg.cn/20200315164109198.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

###### （3）进程的唤醒和阻塞原语

- 进程的阻塞和唤醒原语是`成对存在`的，必须`成对使用`
- `阻塞原语`是由被阻塞进程自我调用实现的
- `唤醒原语`是由一个被唤醒进程合作或被其他相关的进程调用实现的

![](https://img-blog.csdnimg.cn/20200315165047253.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

###### （4）进程的切换原语

![](https://img-blog.csdnimg.cn/20200315165313589.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

- 学习技巧：进程控制会导致进程状态的转换。无论哪个进程控制原语，要做的无非三类事情：
  - 更新PCB中的信息
    - 所有的进程控制原语一定都会修改进程状态标志
    - 剥夺当前运行进程的CPU使用权必然需要保存其运行环境
    - 某进程开始运行前必然要恢复期运行环境
  - 将PCB插入合适的队列
  - 分配/回收资源

#### 2.1.4 进程之间的通信

##### 2.1.4.1 总图

![](https://img-blog.csdnimg.cn/20200315174129868.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 2.1.4.2 什么是进程通信？

- 图中我们可以知道什么是进程通信，以及进程通信的低级和高级方式；

- 我们还可以知道为什么要引入进程通信方式，以及它的意义

  ![](https://img-blog.csdnimg.cn/20200315174420107.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 2.1.4.3 共享储存

- 共享一块大家都可以访问的空间，一次只能有一个进程进行读或写操作

  ![](https://img-blog.csdnimg.cn/20200315174842337.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 2.1.4.4 管道通信

![](https://img-blog.csdnimg.cn/20200315175204500.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 2.1.4.5 消息传递

- 发送信息的进程将消息头写好，接受信息进程根据消息头读取信息或寻找信封是哪一个

  ![](https://img-blog.csdnimg.cn/20200315175843516.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

#### 2.1.5 线程概念与多线程模型

##### 2.1.5.1 总图

![](https://img-blog.csdnimg.cn/20200315204530861.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 2.1.5.2 为什么要引入线程？

![](https://img-blog.csdnimg.cn/20200315212313178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

- 为了方便于理解，我打开了我的任务管理器，可以看出chrome一个进程，下面有很多分支，可以把这些分支当做线程看待，PID即进程和线程都有的标识符。

  ![](https://img-blog.csdnimg.cn/20200315213517930.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 2.1.5.3 什么是线程？

![](https://img-blog.csdnimg.cn/20200315212558942.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 2.1.5.4 引入线程带来的变化及进程与线程的比较

![](https://img-blog.csdnimg.cn/20200315213208509.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 2.1.5.5 线程的属性

![](https://img-blog.csdnimg.cn/20200315213309714.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 2.1.5.6 线程的实现方式

- 前面我们了解了引入线程的好处和引入线程的变化，以及线程的属性，那么线程如何实现呢？
- 线程的实现分为两类：`用户级线程`(User-Level Thread，UTL)和`内核级线程`(Kernel-Level Thread，KTL)。内核级线程又称`内核支持的线程`。

###### （1）用户级线程

![](https://img-blog.csdnimg.cn/20200315214132113.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

###### （2）内核级线程

![](https://img-blog.csdnimg.cn/20200315214338380.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

###### （3）特殊的组合方式及重点注意

![](https://img-blog.csdnimg.cn/20200315214617506.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 2.1.5.7 [多线程](https://so.csdn.net/so/search?q=多线程&spm=1001.2101.3001.7020)模型

- 前面我们提到了线程的实现方式，有用户级和内核级。那么这两种模式的交叉组合就会产生几种不一样的组织结构，即不一样的模型。

###### （1）多对一模型

![](https://img-blog.csdnimg.cn/20200315214830507.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

###### （2）一对一模型

![](https://img-blog.csdnimg.cn/20200315215044546.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

###### （3）多对多模型

- 此种模型效率是三种模型中最好的

![](https://img-blog.csdnimg.cn/20200315215143988.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

#### 习题

##### 1、一个进程映像是（）.

 - 由**协处理器**执行的一个程序
 - 一个独立的程序＋数据集
 - PCB结构与程序和数据的组合
 - 一个独立的程序

 > 进程映像 = PCB+程序段+数据段
 >
 > 辅助处理器（Coprocessor)，也译作**协处理器**，这是一种协助**中央处理器**完成其无法执行或执行效率、效果低下的处理工作而开发和应用的处理器。这种中央处理器无法执行的工作有很多，比如设备间的信号传输、接入设备的管理等:而执行效率、效果低下的有图形处理、声频处理等。为了进行这些处理，各种辅助处理器就诞生了。
 >
 > > C

##### 2、下列关于线程的叙述中，正确的是（）

- 线程包含CPU现场，可以独立执行程序
- 每个线程有自己独立的地址空间
- 进程只能包含一个线程
- 线程之间的通信必须使用系统调用函数

>![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1273/image-20220421104416028.png)
>
>
>
>D可以改成：相同进程的线程之间不一定使用系统调用，不同进程的线程之间必须使用系统调用
>
>> A

##### 3、进程之间交换数据不能通过（）途径进行。

- 共享文件
- 消息传递
- 访问进程地址空间
- 访问共享存储区

>  <img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1273/image-20220421104636963.png" alt="20" style="zoom:60%;" />
>
> 其他进程没有权限访问自己的进程，更不能进行数据交换
>
> > C

##### 4、进程与程序的根本区别是（）.

- 静态和动态特点
- 是不是被调入内存
- 是不是具有就绪、运行和等待三种状态
- 是不是占有处理器

> > A

##### 5、下面的叙述中，正确的是（ ).

- 进程获得处理器运行是通过调度得到的
- 优先级是进程调度的重要依据，一旦确定不能改动
- 在单处理器系统中，任何时刻都只有一个进程处于运行状态
- 进程申请处理器而得不到满足时，其状态变为阻塞状态

>  <img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1273/image-20220421105639496.png" alt="image-20220421105639496" style="zoom:50%;" />
>
> 由上图可知，优先级可以被改动，B❌
>
> <img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1273/image-20220421110024125.png" alt="image-20220421110024125" style="zoom:80%;" />
>
> 由上图可知，就绪态获得处理机转为运行态就是被调度的过程，且只有就绪态可以获得处理机，阻塞态不能直接获得处理机资源，需要先获得其他资源后转为就绪态才可以被调度，从而获得处理机，所以A⭕，D❌
>
> 最后的C是最难判断的，不够严谨，单核处理机系统中有可能出现死锁，所以有可能所有的进程都处于阻塞态，没有处于运行态的进程
>
> > A

##### 6、操作系统是根据（）来对==并发执行==的进程进行控制和管理的。

- 进程的基本状态
- 进程控制块
- 多道程序设计
- 进程的优先权

>在[2.1.1.5 进程的组织](#2.1.1.5 进程的组织)中可以知晓
>
>> B

##### 7、在任何时刻，一个进程的状态变化（）引起另一个进程的状态变化。

- 必定
- 一定不
- 不一定
- 不可能

>一个运行态结束（转化为阻塞态）会导致另一个就绪态转化为运行态
>
>一个阻塞态获得资源（转化为就绪态）不会导致另一个运行态的变化
>
>> C

##### 8、在单处理器系统中，如果同时存在10个进程，则处于就绪队列中的进程最多有（）个。

- 1
- 8
- 9
- 10

> ![image-20220421141402237](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1273/image-20220421141402237.png)
>
> 就绪队列非空——》一定有一个进程处于运行态
>
> 没有进程处于运行态——》就绪对列必为空
>
> > C

##### 9、一个进程释放了一台打印机，它可能会改变（）的状态。

- 自身进程
- 输入/输出进程
- 另一个等待打印机的进程
- 所有等待打印机的进程

>> 显然C

##### 10、假定系统进程所请求的一次l/O操作完成后，将使进程状态从（）

- 运行状态变为就绪状态
- 运行状态变为阻塞状态
- 就绪状态变为运行状态
- 阻塞状态变为就绪状态

> ![image-20220421142030560](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1273/image-20220421142030560.png)
>
> > D

##### 11、并发进程失去封闭性，是指（) 。

- 多个相对独立的进程以各自的速度向前推进
- 并发进程的执行结果与速度无关
- 并发进程执行时，在不同时刻发生的错误
- 并发进程共享变量，其执行结果与速度有关（反复横跳）

> ![image-20220421142532270](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1273/image-20220421142532270.png)
>
> > D

##### 12、一个进程的基本状态可以从其他两种基本状态转变过去，这个基本的状态一定是（）

- 执行状态
- 阻塞态
- 就绪态
- 完成状态

> > C

##### 13、通常用户进程被建立后，( ).

- 便一直存在于系统中，直到被操作人员撤销
- 随着进程运行的正常或不正常结束而撤销
- 随着时间片轮转而撤销与建立
- 随着进程的阻塞或者唤醒而撤销与建立

>进程可以自动结束，不一定要被操作人员手动撤销
>
>进程不会在过程中随着时间片轮转和阻塞或者唤醒而撤销与建立，它只会发生状态的转化，不会消失和增加
>
>> B

##### 14、进程在处理器上执行时，( ).

- 进程之间是无关的，具有封闭特性
- 进程之间都有交互性，相互依赖、相互制约，具有并发性
- 具有并发性，即同时执行的特性
- 进程之间可能是无关的，但也可能是有交互性的

>AB都对，但D更全面
>
>同时是并行，不是并发
>
>> D

##### 15、下面的说法中，正确的是（）.

- 不论是系统支持的线程还是用户级线程，其切换都需要内核的支持
- 线程是资源分配的单位，进程是调度和分派的单位
- 不管系统中是否有线程，进程都是拥有资源的独立单位
- 在引入线程的系统中，进程仍是资源调度和分派的基本单位

> 用户级线程不需要内核
>
> 两个反掉了
>
> 进程是拥有资源的独立单位，其中的多个线程只是共享资源
>
> > C

##### 16、在多对一的线程模型中，当一个多线程进程中的某个线程被阻塞后（ ).

- 该进程的其他线程仍可继续运行
- 整个进程都将阻塞
- 该阻塞线程将被撤销
- 该阻塞线程将永远不可能再执行

> ![image-20220421154144184](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1273/image-20220421154144184.png)
>
> > B

##### 17、用信箱实现进程间互通信息的通信机制要有两个通信原语，它们是（）.

- 发送原语和执行原语
- 就绪原语和执行原语
- 发送原语和接收原语
- 就绪原语和接收原语

>  <img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1273/image-20220421154424263.png" alt="image-20220421154424263" style="zoom:67%;" />

##### 18、下列几种关于进程的叙述，（）最不符合操作系统对进程的理解。

- 进程是在多程序环境中的完整程序
- 进程可以由程序、数据和PCB描述
- 线程（Thread）是一种特殊的进程
- 进程是程序在一个数据集合上的运行过程，它是系统进行资源分配和调度的一个独立单元

>进程和程序不同，前者静态，后者动态
>
>> A

##### 19、支持多道程序设计的操作系统在运行过程中，不断地选择新进程运行来实现CPU的共享，但其中()不是引起操作系统选择新进程的直接原因。

- 运行进程的时间片用完
- 运行进程出错
- 运行进程要等待某一事件发生
- 有新进程进入就绪状态

> ![image-20220421154919429](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1273/image-20220421154919429.png)
>
> > D

##### 20、同一程序经过多次创建，运行在不同的数据集上，形成了（）的进程。

- 不同
- 相同
- 同步
- 互斥

>进程的三大组成（PCB、数据段、程序段）中有任何一个不一样，就是不同的进程
>
>同步：两个进程需相互配合以完成工作
>
>互斥：两个进程互斥地访问临界资源（不可同时访问）
>
>> A

##### 21、PCB是进程存在的唯一标志，下列()不属于PCB。

- 进程ID
- CPU状态
- 堆栈指针
- 全局变量

> ![image-20220421155404883](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1273/image-20220421155404883.png)
>
> ![image-20220421155743430](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1273/image-20220421155743430.png)
>
> ![image-20220421155821954](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1273/image-20220421155821954.png)
>
> > D

##### 22、一个计算机系统中，进程的最大数目主要受到()限制。

- 内存大小
- 用户数目
- 打开的文件数
- 外部设备数量

> A

##### 23、进程创建完成后会进入一个序列，这个序列称为（）.

- 阻塞队列
- 挂起序列
- 就绪队列
- 运行队列

> 系统创建进程时，会给进程分配资源（如分配内存、建立页表），然后就转化为了就绪态，进入就绪对列的队尾
>
> > C

##### 24、在一个多道系统中，若就绪队列不空，就绪的进程数目越多，处理器的效率（）。

- 越高
- 越低
- 不变
- 不确定

> ![image-20220421160551460](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1273/image-20220421160551460.png)
>
> > C

##### 25、在具有通道设备的单处理器系统中实现并发技术后，（）。

- 各进程在某一时刻并行运行，CPU与I/O设备间并行工作
- 各进程在某一时间段内并行运行，CPU与I/O设备间串行工作
- 各进程在某一时间段内并发运行，CPU与I/O设备间并行工作
- 各进程在某一时刻并发运行，CPU与I/O设备间串行工作

> 单处理系统，只能由一个进程，只能进行并发操作
>
> > C

##### 26、进程自身决定（）。

- 从运行态到阻塞态
- 从运行态到就绪态
- 从就绪态到运行态
- 从阻塞态到就绪态

> ![image-20220421161158428](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1273/image-20220421161158428.png)
>
> > A

##### 27、对进程的管理和控制使用（）。

- 指令
- 原语
- 信号量
- 信箱

> 要实现不可中断性
>
> > B

##### 28、下面的叙述中，正确的是（）.

- 引入线程后，处理器只能在线程间切换
- 引入线程后，处理器仍在进程间切换
- 线程的切换，不会引起进程的切换
- 线程的切换，可能引起进程的切换

>  <img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1273/image-20220421161807221.png" alt="image-20220421161807221" style="zoom:67%;" />
>
> > D

##### 29、下面的叙述中，正确的是（）。

- 线程是比进程更小的能独立运行的基本单位，可以脱离进程独立运行
- 引入线程可提高程序并发执行的程度，可进一步提高系统效率
- 线程的引入增加了程序执行时的时空开销
- 一个进程一定包含多个线程

>进程切换：必须切换虚拟地址空间，TLB、Cache中的数据作废
>
>> B

##### 30、下面的叙述中，正确的是（）。

- 同一进程内的线程可并发执行，不同进程的线程只能串行执行
- 同一进程内的线程只能串行执行，不同进程的线程可并发执行
- 同一进程或不同进程内的线程都只能串行执行
- 同一进程或不同进程内的线程都可以并发执行

> > D

##### 31、下列描述中，哪个不是多线程系统的特长（）。

- 利用线程并行地执行矩阵乘法运算
- Web服务器利用线程请求HTTP服务
- 键盘驱动程序为每个正在运行的应用配备一个线程，用来响应相应的键盘输入
- 基于GUI的debugger用不同线程处理用户的输入、计算、跟踪等操作。

>适合用多线程解决的业务场景：可以将处理逻辑拆分成多个互不相干的部分； 计算量较大，需要高并发
>
>> C

##### 32、在进程转换时，下列（）转换是不可能发生的。

- 就绪态→运行态
- 运行态→就绪态
- 运行态→阻塞态
- 阻塞态→运行态

> > D

##### 33、当（）时，进程从执行状态（运行态）转变为就绪态

- 进程被调度程序选中
- 时间片到
- 等待某一事件
- 等待的事件发生

>等待某一事件发生：申请I/O操作（运行——》阻塞）
>
>等待的事件发生：I/O操作完成（阻塞——》就绪）
>
>> B

##### 34、两个合作进程(Cooperating Processes)无法利用（）交换数据。

- 文件系统
- 共享内存
- 高级语言程序设计中的全局变量
- 消息传递系统

> "管道"，就是一种特殊的共享文件，受文件系统的管理，基本只存在于内存当中，普通文件存在于磁盘中
>
> 全局变量存在于进程的数据段中，不同的进程不能访问本进程的数据段，所以也就无法交换全局变量
>
> > C

##### 35、以下可能导致一个进程从运行态变为就绪态的事件是（）.

- 一次IO操作结束
- 运行进程需做I/O操作
- 运行进程结束
- 出现了比现在进程优先级更高的进程

> ![image-20220421165111729](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1273/image-20220421165111729.png)
>
> > D

##### 36、（）必会引起进程切换。

- 一个进程创建后，进入就绪状态
- 一个进程从运行状态变为就绪状态
- 一个进程从阻塞状态变为就绪状态
- 以上答案都不对

> ![image-20220421165322152](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1273/image-20220421165322152.png)
>
> > B

##### 37、进程处于（）时，它是处于非阻塞状态。

- 等待从键盘输入数据
- 等待协作进程的一个信号
- 等待操作系统分配CPU时间
- 等待网络数据进入内存

> 阻塞态：在等待除了CPU之外的某种资源的分配，或等待某事件发生
>
> key：只有其他资源/事件都就位了（就绪态），进程才有资格等待CPU资源的分配
>
> > C

##### 38、一个进程被唤醒，意味着（）.

- 该进程可以重新竞争CPU
- 优先级变大
- PCB移动到就绪队列之首
- 进程变为运行态

> 唤醒：转化为就绪态
>
> > A

##### 39、进程创建时，不需要做的是（）.

- 填写一个该进程的进程表项
- 分配该进程适当的内存
- 将该进程插入就绪队列
- 为该进程分配CPU

>  <img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1273/image-20220421170049924.png" alt="image-20220421170049924" style="zoom:50%;" />
>
> > D

##### 40、计算机两个系统中两个协作进程之间不能用来进行进程间通信的是（）。

- 数据库
- 共享内存
- 消息传递机制
- 管道

> A

##### 41、下列说法中，不正确的是（）.

- 一个进程可以创建一个或多个线程
- 一个线程可以创建一个或多个线程
- 一个线程可以创建一个或多个进程
- 一个进程可以创建一个或多个进程

> 一个进程一定有它的父进程，电脑开机会有一个祖先进程（最高级）
>
> 线程是进程的孩子，线程不能创建进程
>
> > C

---

### 2.2 处理机的调度

#### 2.2.1 处理机调度的概念及层次

##### 2.2.1.1 总览

![](https://img-blog.csdnimg.cn/20200405110107763.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 2.2.1.2 调度的基本概念

![](https://img-blog.csdnimg.cn/20200405103459334.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 2.2.1.3 调度的三个层次

###### （1）高级调度（作业调度）

![](https://img-blog.csdnimg.cn/20200405104148359.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

**作业后备队列**（内存空间有限，有时无法将用户提交的作业全部放入内存）

==作业==：一个具体的任务

用户向系统提交一个作业 ≈ 用户让操作系统启动一个程序（来处理一个具体的任务）

**高级调度**（作业调度）。按一定的原则从外存的作业后备队列中挑选一个作业调入内存，并创建进程（创建PCB）。每个作业只调入一次，调出一次。作业调入时会建立PCB，调出时才撤销PCB。

>简化理解：好几个程序需要启动，到底先启动哪个

###### （2）中级调度（内存调度）

> 本文提到的挂起状态在[（4）进程的挂起状态与七状态模型](# （4）进程的挂起状态与七状态模型)中讲解

![](https://img-blog.csdnimg.cn/20200405104747400.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

>内存不够时，可将某些进程的数据调出外存，等内存空闲或者进程需要运行时再重新调入内存
>
>暂时调到外存等待的进程状态为挂起状态，被挂起的进程PCB会被放到挂起队列
>
>中级调度（内存调度）——按照某种策略**决定**将哪个处于挂起状态的**进程重新调入内存**
>
>一个进程可能会被多次调出、调入内存，因此中级调度发生的**频率要比高级调度更高**

###### （3）低级调度（进程调度）

![](https://img-blog.csdnimg.cn/20200405105806738.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

>低级调度（进程调度/处理机调度）—— 按照某种策略从**就绪队列中选取一个进程**，将处理机分配给它。
>
>进程调度是操作系统中**最基本的一种调度**，在一般的操作系统中都必须配置进程调度。
>
>进程调度的**频率很高**，一般几十毫秒一次。

###### （4）进程的[挂起](https://so.csdn.net/so/search?q=挂起&spm=1001.2101.3001.7020)状态与七状态模型

![](https://img-blog.csdnimg.cn/20200405105331405.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

>**暂时调到外存等待的进程**状态为挂起状态（挂起态，suspend）
>
>挂起态又可以进一步细分为就绪挂起、阻塞挂起两种状态
>
>五状态模型→七状态模型（还是有必要掌握的）

>注意“挂起”和“阻塞”的区别，两种状态都是暂时不能获得CPU的服务，但**挂起态是将进程映像调到外存**去了，而**阻塞态下进程映像还在内存中**。
>
>有的操作系统会把就绪挂起、阻塞挂起分为两个挂起队列，甚至会根据阻塞原因不同再把阻塞挂起进程进一步细分为多个队列。

###### （5）三层调度的联系和对比

![](https://img-blog.csdnimg.cn/20200405105928915.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

#### 2.2.2 进程调度的时机、切换与过程、方式

- 时机（主动放弃与被动放弃）

- 切换与过程（广义与狭义）

- 方式（非剥夺与剥夺）

##### 2.2.2.1 总览

![](https://img-blog.csdnimg.cn/20200405121820679.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 2.2.2.2 时机

> 进程调度（低级调度），就是按照某种算法从就绪队列中选择一个进程为其分配处理机

###### （1）什么时候进行进程调度？

![](https://img-blog.csdnimg.cn/20200405114628967.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

###### （2）什么时候不能进行进程调度？

![](https://img-blog.csdnimg.cn/20200405114714406.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

###### （3）OS内核程序临界区与普通临界区的进程调度情况

![](https://img-blog.csdnimg.cn/20200405115639540.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200405120047821.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 2.2.2.3 进程调度的方式

- 所谓进程调度方式，是指当某个进程正在处理机上执行时，若有某个更为重要或紧迫的进程需要处理，即有优先权更高的进程进入就绪队列，此时应如何分配处理机。

![](https://img-blog.csdnimg.cn/20200405121058772.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 2.2.2.4 进程的切换和过程

![](https://img-blog.csdnimg.cn/20200405121702297.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

- “狭义的进程调度”与“进程切换”的区别：

>**狭义的进程调度**指的是从就绪队列中选中一个要运行的进程。
>
>> 这个进程可以是刚刚被暂停执行的进程，也可能是另一个进程，后一种情况就需要进程切换
>
>**进程切换**是指一个进程让出处理机，由另一个进程占用处理机的过程。
>
>**广义的进程调度**包含了选择一个进程和进程切换两个步骤。
>
>进程切换的过程主要完成了：
>
>- 对原来运行进程各种数据的保存
>
>- 对新的进程各种数据的恢复
>
>  > 如：程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块
>
>注意：**进程切换是有代价的**，因此如果**过于频繁**的**进行进程调度、切换**，必然会使整个系统的**效率降低**，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。

#### 2.2.3 调度算法的评价指标

##### 2.2.3.1 总览

![](https://img-blog.csdnimg.cn/2020040513343928.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 2.2.3.2 CPU利用率

![](https://img-blog.csdnimg.cn/20200405154655867.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 2.2.3.3 系统[吞吐量](https://so.csdn.net/so/search?q=吞吐量&spm=1001.2101.3001.7020)

![](https://img-blog.csdnimg.cn/20200405154830626.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 2.2.3.4 周转时间

![](https://img-blog.csdnimg.cn/20200405155147389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200405155502567.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 2.2.3.5 等待时间

![](https://img-blog.csdnimg.cn/20200405160027655.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 2.2.3.6 响应时间

![](https://img-blog.csdnimg.cn/20200405160127509.png)

#### 2.2.4 作业/进程调度算法

##### 2.2.4.1 总览

![](https://img-blog.csdnimg.cn/2020040516105828.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 2.2.4.2 先来先服务—FCFS

- First Come First Sever

![](https://img-blog.csdnimg.cn/2020040517040648.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200405165950995.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 2.2.4.3 短作业优先—SJF

- Shortest Job First

![](https://img-blog.csdnimg.cn/20200405172738656.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

- 非抢占式—SJF

![](https://img-blog.csdnimg.cn/2020040517103262.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

- 抢占式—SJF(SRTN)

![](https://img-blog.csdnimg.cn/20200405171532909.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200405171826799.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

- 注意几个细节

![](https://img-blog.csdnimg.cn/20200405172617131.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 2.2.4.4 高响应比优先—HRRN

- Highest Response Ratio Next

![](https://img-blog.csdnimg.cn/20200405172958419.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200405210620224.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

> 不会导致饥饿

![](https://img-blog.csdnimg.cn/20200405210349993.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 2.2.4.5 三种算法的对比和总结

![](https://img-blog.csdnimg.cn/20200405210919429.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

#### 2.2.5 调度算法

##### 2.2.5.1 总览

![](https://img-blog.csdnimg.cn/20200405211444596.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 2.2.5.2 时间片轮转—RR

- Round-Robin

![](https://img-blog.csdnimg.cn/20200405213603184.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

- 时间片为2举例

![](https://img-blog.csdnimg.cn/20200405213757453.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200405213832177.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

- 时间片为5举例

![](https://img-blog.csdnimg.cn/2020040521392241.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

- 可能出现的问题，比如与FCFS对比

![](https://img-blog.csdnimg.cn/20200405214042295.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200405214127193.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 2.2.5.3 [优先级调度算法](https://so.csdn.net/so/search?q=优先级调度算法&spm=1001.2101.3001.7020)

![](https://img-blog.csdnimg.cn/20200405215725308.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

- 非抢占式例子

![](https://img-blog.csdnimg.cn/20200405215853251.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

- 抢占式例子

![](https://img-blog.csdnimg.cn/20200405215946222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

- 补充

![](https://img-blog.csdnimg.cn/20200405220031455.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 2.2.5.4 多级反馈[队列](https://so.csdn.net/so/search?q=队列&spm=1001.2101.3001.7020)调度算法

![](https://img-blog.csdnimg.cn/20200405220253285.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200405221721541.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

- 举个例子

![](https://img-blog.csdnimg.cn/20200405221019729.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200405221054732.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200405221231445.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200405221303127.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200405221331548.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/2020040522140067.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 2.2.5.5 三种算法的对比总结

![](https://img-blog.csdnimg.cn/20200405221830211.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

#### 习题

##### 1、时间片轮转调度算法是为了（）。

- 多个用户能及时请求系统服务
- 使系统变得高效
- 优先级较高的进程得到及时响应
- 需要CPU时间最少的进程最先做

> 雨露均沾
>
>  <img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1273/image-20220421171229131.png" alt="image-20220421171229131" style="zoom:67%;" />
>
> 由图可知，有可能更低效
>
> C、D分别是优先级调度、短作业优先调度算法
>
> > A

##### 2、在单处理器的多进程系统中，进程什么时候占用处理器及决定占用时间的长短是由（）决定的。

- 进程相应的代码长度
- 进程总共需要运行的时间
- 进程特点和进程调度策略
- 进程完成什么功能

> > C

##### 3、（）有利于CPU繁忙型的作业，而不利于I/O繁忙型的作业。

- 时间片轮转调度算法
- 先来先服务调度算法
- 短作业（进程）优先算法
- 优先权调度算法

>

##### 4、下面有关选择进程调度算法的准则中，不正确的是（）。

- 尽快响应交互式用户的请求
- 尽量提高处理器利用率
- 尽可能提高系统吞吐量
- 适当增长进程就绪队列的等待时间

> > 显然D

##### 5、设有4个作业同时到达，每个作业的执行时间均为2h，它们在一台处理器上按单道式运行，则平均周转时间为（）.

- 1h
- 5h
- 2.5h
- 8h

>  <img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1273/image-20220421172823468.png" alt="image-20220421172823468" style="zoom:50%;" />
>
> > B

##### 6、若每个作业只能建立一个进程，为了照顾短作业用户，应采用（）；为了照顾紧急作业用户，应采用（）；为了能实现人机交互，应采用（）；而能使短作业、长作业和交互作业用户都满意，应采用（）。

- FCFS调度算法
- 短作业优先调度算法
- 时间片轮转调度算法
- 多级反馈队列调度算法
- 剥夺式优先级调度算法

> > BECD

##### 7、（）优先级是在创建进程时确定的，确定之后在整个运行期间不再改变。

- 先来先服务
- 动态
- 短作业
- 静态

> ![image-20220421200430279](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1273/image-20220421200430279.png)
>
>  <img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1273/image-20220421200437851.png" alt="image-20220421200437851" style="zoom:50%;" />
>
> > D

##### 8、现在有己个同时到达的作业J1、J2和J3，它们的执行时间分别是T1、T2、T3，且T1<T2<T3。系统按单道方式运行且采用短作业优先调度算法，则平均周转时间是（）

- T1+T2+T3
- (3T1+2T2+ T3)/3
- (T1+ T2+ T3)/3
- (T1+2T2+ 3T3)/3

> > B

##### 9、设有三个作业，其运行时间分别是2h、5h、3h，假定它们同时到达，并在同一台处理器上以单道方式运行，则平均周转时间最小的执行顺序是（）。

- J1，J2，3
- J3，J2，J1
- J2，J1，J3
- J1，J3，J2

> 短作业优先，直接按时间顺序排序（从小到大）
>
> > D

##### 10、采用时间片轮转调度算法分配CPU时，当处于运行态的进程用完一个时间片后，它的状态是（）状态。

- 阻塞
- 运行
- 就绪
- 消亡

> 时间片到，或者被抢走处理机，就由运行态转化为就绪态
>
> > C

##### 11、一个作业8∶00到达系统，估计运行时间为1h。若10∶00开始执行该作业，其响应比是（）。

- 2
- 1
- 3
- 0.5

>  <img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1273/image-20220421201348124.png" alt="image-20220421201348124" style="zoom:50%;" />
>
> > C

##### 12、关于优先权大小的论述中，正确的是（）.

- 计算型作业的优先权，应高于I/O型作业的优先权
- 用户进程的优先权，应高于系统进程的优先权
- 在动态优先权中，随着作业等待时间的增加，其优先权随之下降
- 在动态优先权中，随着进程执行时间的增加，其优先权降低

>![image-20220421202028484](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1273/image-20220421202028484.png)
>
>> D

##### 13、下列调度算法中，（）调度算法是绝对可抢占的。

- 先来先服务
- 时间片轮转
- 优先级
- 短进程优先

> > B

##### ==14、==作业是用户提交的，进程是由系统自动生成的，除此之外，两者的区别是（）。

- 两者执行不同的程序段
- 前者以用户任务为单位，后者以操作系统控制为单位
- 前者是批处理的，后者是分时的
- 后者是可并发执行，前者则不同

> > B

##### 15、进程调度算法采用固定时间片轮转调度算法，当时间片过大时，就会使时间片轮转法算法转化为（）调度算法。

- 高响应比优先
- 先来先服务
- 短进程优先
- 以上选项都不对

> 时间片太大，导致每个进程被运行时都可以直接完成，变成了先来先服务算法
>
> > B

##### 16、有5个批处理作业A,B、C、D、E几乎同时到达，其预计运行时间分别为10、6、2、4、8，其优先级（由外部设定）分别为3、5、2、1、4，这里5为最高优先驭。以下各种调度算法中，平均周转时间为14的是（）调度算法。

- 时间片轮转（时间片为1)
- 优先级调度
- 先来先服务（按照顺序10、6、2、4、8 )
- 短作业优先

### 2.3 进程的同步与互斥

#### 2.3.1 同步与互斥

##### 2.3.1.1 总览

![](https://img-blog.csdnimg.cn/20200318133620931.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 2.3.1.2 进程同步

- `同步也称为直接制约关系`。
- 在多道程序环境下，进程是并发执行的，不同进程之间存在着不同的相互制约关系。为了协调进程之间的相互制约关系，如等待、传递信息等，引入了进程同步的概念。进程同步是为了解决进程的异步问题。
- 一个简单的例子来理解这个概念。
- 例如，让系统计算1 + 2 x 3，假设系统产生两个进程：一个是加法进程，一个是乘法进程。要让计算结果是正确的，一定要让加法进程发生在乘法进程之后，但实际上操作系统具有异步性，若不加以制约，加法进程发生在乘法进程之前是绝对有可能的，因此要制定一定的机制去约束加法进程，让它在乘法进程完成之后才发生。

> 异步性：进程具有异步性的特征。异步性是指，各[并发](https://so.csdn.net/so/search?q=并发&spm=1001.2101.3001.7020)执行的进程以各自独立的、不可预知的速度向前推进。

##### 2.3.1.3 进程互斥

- 互斥，亦称间接制约关系。进程互斥指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源。
- 在这里需复习一下临界资源的概念。
- 我们把一个时间段内只允许一个进程使用的资源称为临界资源。许多物理设备（比如摄像头、打印机）都属于临界资源。此外还有许多变量、数据、内存缓冲区等都属于临界资源。
- 对临界资源的访问，必须互斥地进行。

![](https://img-blog.csdnimg.cn/20200318133027576.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

- 为了禁止两个进程同时进入`临界区`，需遵循以下准则

![](https://img-blog.csdnimg.cn/20200318133256733.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

#### 2.3.2 实现临界区进程互斥的软件实现方法

##### 2.3.2.1 总览

![](https://img-blog.csdnimg.cn/20200318133909643.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

- 软件实现方法的思想：在进入区设置并检查一些标志来标明是否有进程在临界区中，若已有进程在临界区，则在进入区通过循环检查进行等待，进程离开临界区后则在退出区修改标志。`入区通过循环检查进行等待，进程离开临界区后则在退出区修改标志。`

##### 2.3.2.2 单标志法

![](https://img-blog.csdnimg.cn/20200318135309589.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200318135416439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 2.3.2.3 双标志先检查法

![](https://img-blog.csdnimg.cn/20200318141000790.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 2.3.2.4 双标志后检查法

![](https://img-blog.csdnimg.cn/20200318141749281.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 2.3.2.5 Peterson算法

![](https://img-blog.csdnimg.cn/20200318145258955.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200318145620865.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

#### 2.3.3 实现临界区进程互斥的硬件实现方法

##### 2.3.3.1 总览

![](https://img-blog.csdnimg.cn/20200318150037360.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 2.3.3.2 [中断](https://so.csdn.net/so/search?q=中断&spm=1001.2101.3001.7020)隐藏方法

![](https://img-blog.csdnimg.cn/20200318150904821.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 2.3.3.3 TestAndSet指令

- 执行TSL指令时，它的内部运转逻辑：
- 假设lock现在为false，代表临界资源A空闲，那么我就可以访问这个资源，同时将lock=true，提醒别的进程，这个临界资源A我正在使用，让他们等等
- 假设lock为true，代表临界资源正在有人使用，所以我必须等待，并且将lock=true，并不影响什么，所以没关系，只是为了让lock为false时可以上锁，将上锁与检查在一个TSL指令完成。

![](https://img-blog.csdnimg.cn/20200318153206214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 2.3.3.4 [Swap](https://so.csdn.net/so/search?q=Swap&spm=1001.2101.3001.7020)指令

- old是每个进程都要进行的一步，都必须将old=true
- 分析一下这样做的原因：
- 因为lock是某一特定临界资源的共享变量，当每一个进程准备访问这个特定的临界资源时，初始化old=true，然后进入while循环进行交换，如果当前lock是false,则交换后old=false,则当前进程可以跳出循环进入临界区代码段，同时因为交换，lock=old=true上锁，不让别的进程来打扰，别的进程会因为lock变为true,一直在while循环等待,当我使用完临界资源，则将lock=false,此时别的进程再交换old和lock就能判断old=false,可以跳出循环，使用临界资源。

![](https://img-blog.csdnimg.cn/20200318164026883.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

#### 2.3.4 信号量机制

##### 2.3.4.1 总览

![](https://img-blog.csdnimg.cn/20200318185721630.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 2.3.4.2 为什么引入[信号量](https://so.csdn.net/so/search?q=信号量&spm=1001.2101.3001.7020)机制？

> 为了更好的解决进程互斥与同步的问题

![](https://img-blog.csdnimg.cn/20200318185634483.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 2.3.4.3 什么是信号量机制？

![](https://img-blog.csdnimg.cn/20200318190256836.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 2.3.4.4 [整型](https://so.csdn.net/so/search?q=整型&spm=1001.2101.3001.7020)信号量

![](https://img-blog.csdnimg.cn/20200318191318959.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 2.3.4.5 记录型信号量

![](https://img-blog.csdnimg.cn/20200318194110945.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

###### （1）举一个生动形象的例子了解记录型信号量

- 一张图咱们回忆一下进程的状态

![](https://img-blog.csdnimg.cn/20200318195109757.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

- 一个例子

  ![](https://img-blog.csdnimg.cn/20200318194828853.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

  ![](https://img-blog.csdnimg.cn/20200318195819903.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

  ![](https://img-blog.csdnimg.cn/20200318200302221.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

  ![](https://img-blog.csdnimg.cn/20200318200616101.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

  ![](https://img-blog.csdnimg.cn/20200318200752726.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

###### （2）梳理一下记录型信号量的知识点（P、V）

![](https://img-blog.csdnimg.cn/2020031820095944.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

#### 2.3.5 信号量机制实现进程的互斥、同步与前驱关系

##### 2.3.5.1 总览

> 在看此小结内容之前，需熟悉前一节[信号量机制](#2.3.4 信号量机制)里面的知识，关于P、V操作内部实现原理等

![](https://img-blog.csdnimg.cn/20200318212838436.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 2.3.5.2 [信号量](https://so.csdn.net/so/search?q=信号量&spm=1001.2101.3001.7020)机制实现进程互斥

![](https://img-blog.csdnimg.cn/20200318213342662.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 2.3.5.3 信号量机制实现进程同步

> 想象一下四则运算的顺序，加减乘除

![](https://img-blog.csdnimg.cn/2020031821343015.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

- 要想理解这一部分知识，必须知道P、V操作的内部实现原理

![](https://img-blog.csdnimg.cn/20200318214033750.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 2.3.5.4 信号量机制实现前驱关系

![](https://img-blog.csdnimg.cn/20200318214258129.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

#### 2.3.6 进程同步与互斥经典问题

- 生产者-消费者问题
- 多生产者-多消费者问题
- 吸烟者问题
- 读者-写者问题
- 哲学家进餐问题

##### 2.3.6.1 总览

> 同步时，先V后P

![](https://img-blog.csdnimg.cn/20200326161245893.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 2.3.6.2 生产者-消费者问题

###### （1）问题描述

- 系统中有`一组生产者进程`和`一组消费者进程`，生产者进程每次`生产一个`产品放入缓冲区，消费者进程每次从缓冲区中`取出一个`产品并使用。(注: 这里的“产品”理解为某种数据)
- 生产者、消费者`共享`一个初始为空、大小为n的`缓冲区`。
- 只有缓冲区`没满`时，`生产者`才能把产品`放入`缓冲区，否则必须等待。
- 只有缓冲区`不空`时，`消费者`才能从中`取出`产品，否则必须等待。
- 缓冲区是临界资源，各进程必须`互斥`地访问。

![](https://img-blog.csdnimg.cn/20200326160410823.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

###### （2）问题分析

- 1)关系分析。生产者和消费者对缓冲区互斥访问是`互斥关系`，同时生产者和消费者又是一个相互协作的关系，只有生产者生产之后,消费者才能消费，它们也是`同步关系`。
- 2)整理思路。根据各进程的操作流程确定P、V操作的大致顺序。
  生产者每次要消耗(P）一个空闲缓冲区，并生产(V)一个产品。
  消费者每次要消耗(P）一个产品，并释放一个空闲缓冲区(V)。
  往缓冲区放入/取走产品需要互斥。
- 3)信号量设置。设置信号量。设置需要的信号量，并根据题目条件确定信号量初值。( 互斥信号量初值一般为1，同步信号量的初始值要看对应资源的初始值是多少)

![](https://img-blog.csdnimg.cn/20200326161730802.png)

###### （3）如何实现？

![](https://img-blog.csdnimg.cn/20200326162426621.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

###### （4）实现互斥的P操作一定要在实现同步的P操作之后

![](https://img-blog.csdnimg.cn/20200326163748660.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

###### （5）知识回顾与重要考点

![](https://img-blog.csdnimg.cn/20200326164924620.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 2.3.6.3 多生产者-多消费者问题

###### （1）问题描述

![](https://img-blog.csdnimg.cn/20200326194455856.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

###### （2）问题分析

![](https://img-blog.csdnimg.cn/20200326195138928.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

###### （3）实现方法

- 有mutex

  ![](https://img-blog.csdnimg.cn/2020032619533967.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

- 无mutex

  ![](https://img-blog.csdnimg.cn/20200326195647665.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

- 为什么有mutex和没有mutex一样呢？

  > 原因在于:本题中的缓冲区大小为1，在任何时刻，apple、 orange、 plate 三个同步信号量中最多只有一个是1。因此在任何时刻，最多只有一个进程的P操作不会被阻塞，并顺利地进入临界区…

- 如果有两个盘子plate

  ![](https://img-blog.csdnimg.cn/2020032620004310.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

###### （4）知识总结与重要考点

- `总结`:在生产者_消费者问题中，如果缓冲区大小为1，那么有可能不需要设置互斥信号量就可以实现互斥访问缓冲区的功能。当然，`这不是绝对的`，要具体问题具体分析。
- `建议`:在考试中如果来不及仔细分析，可以加上互斥信号量，保证各进程一定会互斥地访问缓冲区。但需要注意的是，·`实现互斥的P操作一定要在实现同步的P操作之后`·，否则可能引起·`“死锁”`·。

![](https://img-blog.csdnimg.cn/2020032620050663.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 2.3.6.4 读者-写者问题

###### （1）问题描述

![](https://img-blog.csdnimg.cn/20200326212209866.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

###### （2）问题分析

![](https://img-blog.csdnimg.cn/20200326212257409.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

###### （3）实现方法

- 给count加mutex互斥访问

  - 这里说一下为什么要加mutex。
  - 比如：当count=0时，第一个读者进程执行到p(rw)，rw=0,假设此时时间片到了，切换到第二个读者进程，第二个进程发现count=0,则执行p(rw)，但是此时rw=0，于是第二个进程被堵在p（rw）这里，同理，后面的可能会有多个进程堵在p(rw)，只有当第一个进程再次获得时间片，执行count++，让count不为0，然后其他进程就可以直接绕过if直接进行count++来访问文件，但是第三个读者进程和后面的几个可能堵在p(rw)的多个读者进程则必须得等count–为0后才可以再次和写进程竞争来访问文件，对count的访问没有做到一气呵成，会导致本来一些进程一直堵在p（rw）。

  ![](https://img-blog.csdnimg.cn/20200326214332716.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

- 加一个w实现“读写公平法”

  - 在上面的算法中，读进程是优先的，即当存在读进程时，写操作将被延迟，且只要有 一个读进程活跃，随后而来的读进程都将被允许访问文件。这样的方式会导致写进程可能长时间等待，且存在写进程`“饿死”`的情况。
  - 若希望写进程优先，`即当有读进程正在读共享文件时，有写进程请求访问，这时应禁止后续读进程的请求，等到已在共享文件的读进程执行完毕，立即让写进程执行，只有在无写进程执行的情况下才允许读进程再次运行`。为此，增加一个信号量并在上面程序的writer()和 reader()函数中各增加一对PV操作，就可以得到写进程优先的解决程序。

  ![](https://img-blog.csdnimg.cn/20200326221227585.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

###### （4）知识回顾与重要考点

![](https://img-blog.csdnimg.cn/20200326221603321.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 2.3.6.5 吸烟者问题

###### （1）问题描述

![](https://img-blog.csdnimg.cn/20200326224445783.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

###### （2）问题分析

![](https://img-blog.csdnimg.cn/20200326224559853.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200326224647836.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

###### （3）实现方法

![](https://img-blog.csdnimg.cn/20200326224818298.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

###### （4）知识回顾与重要考点

![](https://img-blog.csdnimg.cn/20200326231438604.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 2.3.6.6 哲学家进餐问题

###### （1）问题描述

![](https://img-blog.csdnimg.cn/2020032622554120.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

###### （2）问题分析

![](https://img-blog.csdnimg.cn/20200326230006256.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

###### （3）如何实现

![](https://img-blog.csdnimg.cn/20200326230501827.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200326230535948.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200326231222488.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

###### （4）知识回顾与重要考点

![](https://img-blog.csdnimg.cn/20200326231308386.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

#### 2.3.7 管程和java中实现管程的机制

##### 2.3.7.1 总览

![](https://img-blog.csdnimg.cn/20200409213147689.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 2.3.7.2 为什么引入管程？

![](https://img-blog.csdnimg.cn/20200409213420351.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 2.3.7.3 管程的组成及基本特征

![](https://img-blog.csdnimg.cn/20200409214937653.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 2.3.7.4 管程实现生产者消费者问题

![](https://img-blog.csdnimg.cn/20200409215917223.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200409215948281.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200409220031588.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/2020040922101210.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 2.3.7.5 java中类似于管程的机制

![](https://img-blog.csdnimg.cn/20200409221447474.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

#### 习题

##### 1、下列对临界区的论述中，正确的是（）。

- 临界区是指进程中用于实现进程互斥的那段代码
- 临界区是指进程中用于实现进程同步的那段代码
- 临界区是指进程中用于实现进程通信的那段代码
- 临界区是指进程中用于访问共享资源的那段代码

> ![image-20220425142820619](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1273/image-20220425142820619.png)
>
> > D

##### 2、不需要信号量就能实现的功能是（）.

- 进程同步
- 进程互斥
- 执行的前驱关系
- 进程的并发执行

> ![image-20220425144017466](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1273/image-20220425144017466.png)
>
> > D

##### 3、若一个信号量的初值为3，经过多次PV操作后当前值为-1，这表示等待进入临界区的进程数是（）.

- 1
- 2
- 3
- 4

>![image-20220425144448584](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1273/image-20220425144448584.png)
>
>> A

##### 4、一个正在访问临界资源的进程由于申请等待I/O操作而被中断时，它是（）。

- 可以允许其他进程进入与该进程相关的临界区
- 不允许其他进程进入任何临界区
- 可以允许其他进程抢占处理器，但不得进入该进程的临界区
- 不允许任何进程抢占处理器

> ![image-20220425144714279](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1273/image-20220425144714279.png)
>
> > C

##### 5、两个旅行社甲和乙为旅客到某航空公司订飞机票，形成互斥资源的是（）.

- 旅行社
- 航空公司
- 飞机票
- 旅行社与航空公司

> > 显然C

##### 6、临界区是指并发进程访问共享变量段的（）。

- 管理信息
- 信息存储
- 数据
- 代码程序

> ![image-20220425144949616](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1273/image-20220425144949616.png)
>
> > D

##### 7、以下不是同步机制应遵循的准则的是（）.

- 让权等待
- 空闲让进
- 忙则等待
- 无限等待

> > D

##### 8、以下（）不属于临界资源。

- 打印机
- 非共享数据
- 共享变量
- 共享缓冲区

> 
>
> > D

##### 9、以下（）属于临界资源

- 磁盘存储介质
- 公用队列
- 私用数据
- 可重入的程序代码

> ![image-20220425150424819](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1273/image-20220425150424819.png)
>
> > B

##### 10、在操作系统中，要对并发进程进行同步的原因是（）.

- 进程必须在有限的时间内完成
- 进程具有动态性
- 并发进程是异步的
- 进程具有结构性

> ![image-20220425154341574](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1273/image-20220425154341574.png)
>
> > C

##### 11、进程A和进程B通过共享缓冲区协作完成数据处理，进程A负责产生数据并放入缓冲区，进程B从缓冲区读数据并输出。进程A和进程B之间的制约关系是（）.

- 互斥关系
- 同步关系
- 互斥和同步关系
- 无制约关系

> ![image-20220425154752210](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1273/image-20220425154752210.png)
>
> > C

##### 12、在操作系统中，P、V操作是一种（）.

- 机器指令
- 系统调用命令
- 作业控制命令
- 低级进程通信

>![image-20220425194546325](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1273/image-20220425194546325.png)
>
>> D

##### 13、P操作可能导致（）.

- 进程就绪
- 进程结束
- 进程阻塞
- 新进程创建

> V操作可能导致进程就绪
>
> > C

##### 14、原语是（）。

- 运行在用户态的过程
- 操作系统的内核
- 可中断的指令序列
- 不可分割的指令序列

>![image-20220425195604876](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1273/image-20220425195604876.png)
>
>原语属于操作系统内核的一部分
>
>> D

15、（）定义了共享数据结构和各种进程在该数据结构上的全部操作。

- 管程
- 类程
- 线程
- 程序

### 2.4 死锁

#### 2.4.1.1 总览

![](https://img-blog.csdnimg.cn/20200410230641280.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

#### 2.4.1.2 什么是死锁？

![](https://img-blog.csdnimg.cn/20200410170259874.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200410170357702.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

#### 2.4.1.3 死锁、饥饿、死循环的区别

![](https://img-blog.csdnimg.cn/20200410174921371.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200410174557145.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

#### 2.4.1.4 死锁产生的四个必要条件

- 互斥
- 不可剥夺
- 请求与等待
- 循环等待

![](https://img-blog.csdnimg.cn/20200410175208280.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

#### 2.4.1.5 什么时候会发生死锁？

![](https://img-blog.csdnimg.cn/20200410180108539.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

#### 2.4.1.6 死锁的处理策略

![](https://img-blog.csdnimg.cn/20200410180754634.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

###### （1）预防死锁

- 破坏互斥条件

  ![](https://img-blog.csdnimg.cn/20200410201024997.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

- 破坏不可剥夺条件

  ![](https://img-blog.csdnimg.cn/20200410201439114.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

- 破坏请求和保持条件

  ![](https://img-blog.csdnimg.cn/20200410202200723.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

- 破坏循环等待条件

  ![](https://img-blog.csdnimg.cn/20200410202832127.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

###### （2）避免死锁（银行家算法）

- 什么是安全序列？

![](https://img-blog.csdnimg.cn/20200410203747126.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200410203841364.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200410204002195.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200410204200246.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200410204302355.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/2020041020473596.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200410204824431.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

- 避免系统进入不安全状态------[银行家算法](https://so.csdn.net/so/search?q=银行家算法&spm=1001.2101.3001.7020)

  > 可以用回溯来理解，也是Dijkstra这个老表想出来的

![](https://img-blog.csdnimg.cn/20200410210623383.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200410210823312.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200410210924989.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200410211041533.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200410211147283.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200410211254133.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200410211355933.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200410211540255.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

- 使用代码实现

![](https://img-blog.csdnimg.cn/20200410212331536.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200410212719472.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200410213100685.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

###### （3）死锁的检测和解除

![](https://img-blog.csdnimg.cn/20200410213835909.png)

- 死锁的检测

  ![](https://img-blog.csdnimg.cn/20200410214408124.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

> 举个例子，可以消除所有边，即无死锁发生

![](https://img-blog.csdnimg.cn/20200410215222377.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200410215058630.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200410215336834.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

> 举个例子，不可消除所有边，即产生死锁

![](https://img-blog.csdnimg.cn/2020041021590531.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200410220045518.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200410220119906.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200410220703987.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

- 死锁的解除

  ![](https://img-blog.csdnimg.cn/20200410221433883.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

#### 习题

## 第 3 章 内存管理

### 3.1 内存管理的概念

#### 3.1.1 什么是内存？

> 进程的基本原理，深入指令理解其过程

##### 3.1.1.1 总览

![](https://img-blog.csdnimg.cn/20200421170005542.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 3.1.1.2 什么是内存？有何作用？

![](https://img-blog.csdnimg.cn/20200421170213774.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

###### （1）[存储单元](https://so.csdn.net/so/search?q=存储单元&spm=1001.2101.3001.7020)

> 关于存储单元有关内容在我写的组成原理笔记中有提到：[存储单元](https://blog.csdn.net/weixin_43914604/article/details/104099953)

![](https://img-blog.csdnimg.cn/20200421170913619.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

> 内存可存放数据。程序执行前**需要先放到内存中才能被CPU处理**——缓和CPU与硬盘之间的速度矛盾

###### （2）几个常用数量单位&内存地址

![](https://img-blog.csdnimg.cn/20200421171510336.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 3.1.1.3 进程运行的基本原理

###### （1）指令的工作原理——操作码+若干参数（可能包含地址参数）

- 从X=X+1大致看一下指令的执行过程

  ![](https://img-blog.csdnimg.cn/20200421172536502.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

  ![](https://img-blog.csdnimg.cn/20200421172647125.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

  ![](https://img-blog.csdnimg.cn/20200421172713286.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

  ![](https://img-blog.csdnimg.cn/20200421173012112.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

###### （2）[逻辑地址](https://so.csdn.net/so/search?q=逻辑地址&spm=1001.2101.3001.7020)（相对地址）vs物理地址（绝对地址）

![](https://img-blog.csdnimg.cn/2020042117344477.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

###### （3）从写程序到程序运行——编译、链接、装入

![](https://img-blog.csdnimg.cn/20200421180308143.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

>编译：由`编译程序`将用户源代码编译成若干个目标模块（编译就是把高级语言**翻译为机器语言**）
>
>链接：由`链接程序`将编译后形成的一组目标模块，以及所需库函数链接在一起，形成一个完整的装入模块
>
>装入（装载）：由`装入程序`将装入模块装入内存运行

###### （4）装入模块装入内存

**不修改装入模块中的指令地址就直接装入内存的话：**

![](https://img-blog.csdnimg.cn/20200421182039112.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200421182303963.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

###### （5）装入的三种方式

- 绝对装入

  > 绝对装入：**在编译时**，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码。
  >
  > 装入程序按照装入模块中的地址，将程序和数据装入内存。

  ![](https://img-blog.csdnimg.cn/20200421202025892.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

  >绝对装入只适用于单道程序环境。
  >
  >程序中使用的绝对地址，可在编译或汇编时给出，也可由程序员直接赋予。通常情况下都是编译或汇编时再转换为绝对地址。

- 静态重定位

  > 静态重定位：又称`可重定位装入`。编译、链接后的装入模块的地址都是从0开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对地址进行“重定位”，将逻辑地址变换为物理地址（地址变换是在装入时一次完成的）。

  ![](https://img-blog.csdnimg.cn/20200421202117615.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

  > 静态重定位的特点是在一个作业装入内存时，**必须分配其要求的全部内存空间**，如果没有足够的内存，就不能装入该作业。作业一旦进入内存后，**在运行期间就不能再移动**，也不能再申请内存空间。

- 动态重定位

  > 动态重定位：又称`动态运行时装入`。编译、链接后的装入模块的地址都是从0开始的。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是**把地址转换推迟到程序真正要执行时才进行**。因此装入内存后所有的地址依然是逻辑地址。这种方式需要一个**重定位寄存器**的支持。

  ![](https://img-blog.csdnimg.cn/20200421202516120.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

  ![](https://img-blog.csdnimg.cn/20200421202728962.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)
  
  > 重定位寄存器：存放装入模块存放的**起始位置**
  >
  > > 采用动态重定位时**允许程序在内存中发生移动**
  
  ![](https://img-blog.csdnimg.cn/20200421202859982.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)
  
  > 并且可将程序分配到不连续的存储区中；在程序运行前只需装入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存；便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间

###### （6）链接的三种方式

- 静态链接

  > 在程序运行之前，先将各目标模块及它们所需的库函数连接成一个完整的可执行文件（装入模块），之后不再拆开。

  ![](https://img-blog.csdnimg.cn/20200421203135471.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

- 装入时动态链接

  > 将各目标模块装入内存时，边装入边链接的链接方式。

  ![](https://img-blog.csdnimg.cn/20200421203248608.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

- 运行时动态链接

  > 在程序执行中需要该目标模块时，才对它进行链接。其优点是便于修改和更新，便于实现对目标模块的共享。
  
  ![](https://img-blog.csdnimg.cn/20200421203435485.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)
  
  >用不到的模块不要装入内存

#### 3.1.2 内存管理管些什么？

##### 3.1.2.1 总览

![](https://img-blog.csdnimg.cn/20200421204131495.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 3.1.2.2 内存空间的分配与回收

![](https://img-blog.csdnimg.cn/20200421204343725.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 3.1.2.3 内存空间的扩展（实现虚拟性）

![](https://img-blog.csdnimg.cn/20200421204522537.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 3.1.2.4 [地址转换](https://so.csdn.net/so/search?q=地址转换&spm=1001.2101.3001.7020)

![](https://img-blog.csdnimg.cn/20200421204834534.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

- 三种方式

![](https://img-blog.csdnimg.cn/20200421204937503.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 3.1.2.5 内存保护

![](https://img-blog.csdnimg.cn/20200421205035855.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

- 两种方式

  ![](https://img-blog.csdnimg.cn/20200421205354626.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

  ![](https://img-blog.csdnimg.cn/20200421205641907.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

#### 3.1.3 覆盖技术与交换技术的思想

##### 3.1.3.1 总览

![](https://img-blog.csdnimg.cn/20200423175639916.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 3.1.3.2 覆盖技术

> 后来人们引入了覆盖技术，用来解决“程序大小超过物理内存总和”的问题

![](https://img-blog.csdnimg.cn/2020042318025985.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

>覆盖技术的思想：将程序分为多个段（多个模块）。常用的段常驻内存，不常用的段在需要时调入内存。
>
>内存中分为一个“固定区”和若干个“覆盖区”
>
>需要常驻内存的段放在“固定区”中，调入后就不再调出（除非运行结束）
>
>不常用的段放在“覆盖区”，需要用到时调入内存，用不到时调出内存

![](https://img-blog.csdnimg.cn/20200423180820382.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

>必须由程序员声明覆盖结构，操作系统完成自动覆盖。缺点：对用户不透明，增加了用户编程负担。
>
>> 覆盖技术只用于早期的操作系统中，现在已成为历史。

##### 3.1.3.3 交换技术

> 交换（对换）技术的设计思想：内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存（进程在内存与磁盘间动态调度）

![](https://img-blog.csdnimg.cn/20200423181112552.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

- 回忆复习一下进程调度

![](https://img-blog.csdnimg.cn/20200423181400473.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200423182501764.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

>1．具有对换功能的操作系统中，通常把磁盘空间分为`文件区`和`对换区`两部分。文件区主要用于存放文件，**主要追求存储空间的利用率**，因此对文件区空间的管理**采用离散分配方式**；对换区空间只占磁盘空间的小部分，**被换出的进程数据就存放在对换区**。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理**主要追求换入换出速度**，因此通常对换区**采用连续分配方式**（学过文件管理章节后即可理解）。总之，**对换区的I/O速度比文件区的更快**。
>
>2．交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停。例如:在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程;如果缺页率明显下降，就可以暂停换出。
>
>3．可优先换出阻塞进程;可换出优先级低的进程;为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间...
>
>(注意：**PCB会常驻内存**，不会被换出外存)

#### 3.1.4 内存的分配与回收

##### 3.1.4.1 总览

![](https://img-blog.csdnimg.cn/20200423183217819.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200423183108555.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 3.1.4.2 单一连续分配

>在单一连续分配方式中，内存被分为`系统区`和`用户区`。`系统区`通常位于内存的低地址部分，用于**存放操作系统相关数据**；`用户区`用于**存放用户进程相关数据**。
>
>内存中**只能有一道用户程序**，用户程序独占整个用户区空间。

![](https://img-blog.csdnimg.cn/20200423183833877.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

>优点：实现简单；无外部碎片；可以采用覆盖技术扩充内存；不一定需要采取内存保护（eg：早期的PC操作系统MS-DOS）。
>
>缺点：只能用于单用户、单任务的操作系统中；有内部碎片；存储器利用率极低。
>
>> 分配给某进程的内存区域中，如果有些部分没有用上，就是“内部碎片”

##### 3.1.4.3 固定分区分配

![](https://img-blog.csdnimg.cn/20200423184230246.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

###### （1）分区说明表

> 操作系统需要建立一个数据结构——分区说明表，来实现各个分区的分配与回收。每个表项对应一个分区，通常按分区大小排列。每个表项包括对应分区的大小、起始地址、状态（是否已分配）。

![](https://img-blog.csdnimg.cn/20200423184627961.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

>优点：简单，**无外部碎片**。
>
>缺点：a.当用户程序太大时，可能所有的分区都不能满足需求，此时不得不采用覆盖技术来解决，但这又会降低性能；b.**会产生内部碎片**，内存利用率低。

##### 3.1.4.4 动态分区分配（可变分区分配）

> 动态分区分配又称为`可变分区分配`。这种分配方式**不会预先划分内存分区**，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。（eg：假设某计算机内存大小为64MB，系统区8MB，用户区共56 MB.…）

![](https://img-blog.csdnimg.cn/2020042318520337.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200423185321400.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200423185425770.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

###### （1）系统要用怎样的[数据结构](https://so.csdn.net/so/search?q=数据结构&spm=1001.2101.3001.7020)记录内存的使用情况呢？

>空闲分区表：每个空闲分区对应一个表项。表项中包含分区号分区大小、分区起始地址等信息
>
>空闲分区链：每个分区的起始部分和末尾部分分别设置前向指针和后向指针。起始部分处还可记录分区大小等信息

![](https://img-blog.csdnimg.cn/2020042321042395.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

###### （2）当多个空闲分区都能满足要求时，应该选择哪个分区进行分配？

![](https://img-blog.csdnimg.cn/20200423210641126.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

###### （3）如何进行分区的分配和回收操作？

> **如何分配？**

![](https://img-blog.csdnimg.cn/20200423210951871.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200423211031656.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200423211234282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

> **如何回收？**

![](https://img-blog.csdnimg.cn/20200423211626193.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200423211751743.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200423211954749.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200423212108969.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 3.1.4.5 内部碎片与外部碎片

![](https://img-blog.csdnimg.cn/20200423212544902.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

> 外部碎片，是指内存中的某些空闲分区由于太小而难以利用

![](https://img-blog.csdnimg.cn/20200423212650781.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

#### 3.1.5 动态分区分配的四种算法

> ​	本篇文章是对上一篇文章[内存的分配与回收](#3.1.4 内存的分配与回收)提到的`动态分区分配算法`的补充

- 首次适应算法
- 最佳适应算法
- 最坏适应算法
- 临近适应算法

##### 3.1.5.1 总览

![](https://img-blog.csdnimg.cn/20200423213918738.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 3.1.5.2 首次适应算法

![](https://img-blog.csdnimg.cn/2020042321452336.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200423214600818.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/2020042321465411.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 3.1.5.3 [最佳适应算法](https://so.csdn.net/so/search?q=最佳适应算法&spm=1001.2101.3001.7020)

![](https://img-blog.csdnimg.cn/20200423215641164.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200423215758679.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/2020042321590110.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 3.1.5.4 最坏（大）适应算法

![](https://img-blog.csdnimg.cn/20200423220300386.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200423220432246.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200423220549394.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200423220633433.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 3.1.5.5 临近适应算法

![](https://img-blog.csdnimg.cn/20200423220900503.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200423220937204.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200423221300749.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200423221401765.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200423221603115.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 3.1.5.6 四种算法归纳比较

![](https://img-blog.csdnimg.cn/20200423221937764.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

#### 3.1.6 分页存储（页号、页偏移量等）

##### 3.1.6.1 总览

![](https://img-blog.csdnimg.cn/2020050319145526.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200503190414618.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 3.1.6.2 为什么学习分页存储？

![](https://img-blog.csdnimg.cn/20200503191058819.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 3.1.6.3 基本分页存储管理的思想

> 基本分页存储管理的思想——把内存分为一个个相等的小分区，再按照分区大小把进程拆分成一个个小部分，显然，如果把分区大小设置的越小一些，内部碎片会更小，内存利用率会更高。

![](https://img-blog.csdnimg.cn/20200503191933864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 3.1.6.4 分页存储管理的重要概念

> 将内存空间分为一个个大小相等的分区（比如：每个分区4KB），每个分区就是一个“页框”，或称“页帧”、“内存块”、“物理块”。每个页框有一个编号，即“页框号”（或者“内存块号”、“页帧号”、“物理块号”）页框号从0开始。

>将用户进程的地址空间也分为与页框大小相等的一个个区域，称为“页”或“页面”。每个页面也有一个编号，即“页号”，页号也是从0开始。
>（注：进程的最后一个页面可能没有一个页框那么大。因此，页框不能太大，否则可能产生过大的内部碎片）

![](https://img-blog.csdnimg.cn/20200503192356252.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

>操作系统**以页框为单位为各个进程分配**内存空间，进程的每个页面分别放入一个页框中，也就是说，进程的`页面`与内存的`页框`有**一一对应**的关系。
>
>各个页面不必连续存放，也不必按先后顺序来，可以放到不相邻的各个页框中。

##### 3.1.6.5 如何实现地址的转换

![](https://img-blog.csdnimg.cn/20200503192553130.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200503194743868.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200503215055931.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

###### （1）如何计算页号和页偏移量

> 为了方便计算页号、页内偏移量，页面大小一般设为2的整数幂

>页号 = 逻辑地址 / 页面长度（取除法的整数部分）
>
>页内偏移量 = 逻辑地址 % 页面长度（取除法的余数部分）
>
>页面**在内存中的起始位置**：操作系统需要用某种数据结构记录进程各个页面的起始位置。

![](https://img-blog.csdnimg.cn/20200503215344637.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

**为什么页面大小一般设为2的整数次幂？**

![](https://img-blog.csdnimg.cn/20200503215910111.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200503220214800.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

>结论：如果每个页面大小为`2^k`B，用二进制数表示逻辑地址，则末尾K位即为页内偏移量，其余部分就是页号
>
>因此，如果让每个页面的大小为2的整数幂，计算机就可以很方便地得出一个逻辑地址对应的页号和页内偏移量

###### （2）分页存储的逻辑结构

> 地址结构包含两个部分：前一部分为页号，后一部分为页内偏移量W

> 如果有K位表示“页内偏移量”，则说明该系统中一个页面的大小是`2^K`个内存单元
>
> 如果有M位表示“页号”，则说明在该系统中，一个进程最多允许有`2^M`个页面

![](https://img-blog.csdnimg.cn/20200503220607170.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

###### （3）如何知道页面在[内存](https://so.csdn.net/so/search?q=内存&spm=1001.2101.3001.7020)中的起始地址？

- 这里引入一个新的概念：`页表`

  > 为了能知道进程的每个页面在内存中存放的位置，操作系统要**为每个进程建立一张页表**。

  ![](https://img-blog.csdnimg.cn/20200503220952295.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)
  
  ![](https://img-blog.csdnimg.cn/20200503221250554.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

#### 3.1.7 分页存储管理的基本地址变换结构

##### 3.1.7.1 总览

![](https://img-blog.csdnimg.cn/20200503222023592.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200503221903305.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 3.1.7.2 [页表](https://so.csdn.net/so/search?q=页表&spm=1001.2101.3001.7020)寄存器

>基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址。
>
>通常会在系统中设置一个`页表寄存器`(PTR），存放**页表在内存中的起始地址F**和**页表长度M**。
>
>进程未执行时，`页表的始址`和`页表长度`放在**进程控制块（PCB）**中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。

![](https://img-blog.csdnimg.cn/20200503222207602.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

- 地址变换过程

  >程序计数器PC：指向下一条指令的逻辑地址A

  > 进程切换相关的内核程序负责恢复进程运行环境

![](https://img-blog.csdnimg.cn/20200503223729773.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200503223548369.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200503224323607.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

>设页面大小为L，逻辑地址A到物理地址E的变换过程如下：
>
>①计算页号Р和页内偏移量W（如果用十进制数手算，则P = A / L，W = A % L；但是在计算机实际运行时，逻辑地址结构是固定不变的，因此计算机硬件可以更快地得到二进制表示的页号、页内偏移量）
>
>②比较页号P和页表长度M，若P >= M，则产生越界中断，否则继续执行。（注意页号是从0开始的，而页表长度至少是1，因此P = M时也会越界）
>
>③页表中页号P对应的页表项地址 = 页表起始地址F + 页号P * 页表项长度，取出该页表项内容b，即为内存块号。（注意区分页表项长度、页表长度、页面大小的区别。页表长度指的是这个页表中总共有几个页表项，即总共有几个页；页表项长度指的是每个页表项占多大的存储空间；页面大小指的是一个页面占多大的存储空间）
>
>④计算E = b * L + W，用得到的物理地址E去访存。（如果内存块号、页面偏移量是用二进制表示的，那么把二者拼接起来就是最终的物理地址了）

**一道例题加深印象：**

![](https://img-blog.csdnimg.cn/20200503225214679.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 3.1.7.3 对页表项大小的进一步讨论

![](https://img-blog.csdnimg.cn/20200503230227132.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

#### 3.1.8 快表的地址变换结构

> 上一篇文章学习了[分页存储管理的基本地址变换结构](#3.1.7 分页存储管理的基本地址变换结构)，这一篇文章是对基本地址变换结构的改进版。

##### 3.1.8.1 总览

![](https://img-blog.csdnimg.cn/20200505110318550.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 3.1.8.2 局部性原理引入快表机制

> 上小节介绍的基本地址变换机构中，每次要访问一个逻辑地址，都需要查询内存中的页表。由于局部性原理，可能连续很多次查到的都是同一个页表项。既然如此，能否利用这个特性减少访问页表的次数呢?——快表机制

![](https://img-blog.csdnimg.cn/20200505111434415.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

>时间局部性：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久之后该数据很可能再次被访问。（因为程序中存在大量的循环）
>
>空间局部性：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。（因为很多数据在内存中都是连续存放的）

##### 3.1.8.3 快表（TLB）

![](https://img-blog.csdnimg.cn/20200505111455765.png)

###### 一个例图了解基于快表的地址变换结构

![](https://img-blog.csdnimg.cn/20200505112605873.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

**引入快表后，地址变换的过程的文字描述：**

![](https://img-blog.csdnimg.cn/20200505114142450.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

###### 3.1.8.4 基本地址变换与快表地址变换的比较

![](https://img-blog.csdnimg.cn/2020050511441885.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

#### 3.1.9 二级页表的原理和地址结构

##### 3.1.9.1 总览

![](https://img-blog.csdnimg.cn/20200505121003522.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 3.1.9.2 为什么引入二级[页表](https://so.csdn.net/so/search?q=页表&spm=1001.2101.3001.7020)？

**因为单级页表存在一些问题，所以引入二级页表和多级页表，有两个问题：**

![](https://img-blog.csdnimg.cn/20200505125243303.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200505125432184.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

**上面提到了这两个问题，那么总结一下，并提出解决思想，引入二级页表的概念。**

> 发现问题——》提出方法——》解决问题

![](https://img-blog.csdnimg.cn/20200505125857508.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 3.1.9.3 二级页表的原理和地址结构

- 对页表再次分组

  ![](https://img-blog.csdnimg.cn/20200505131124485.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

- 二级页表的地址结构及对应关系

  ![](https://img-blog.csdnimg.cn/20200505131519939.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 3.1.9.4 如何实现二级页表的地址变换？

![](https://img-blog.csdnimg.cn/20200505133306791.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

> **上面的部分我们解决了问题一，接下来是问题二，这里简单叙述一下，后面的文章会继续深入剖析。**

![](https://img-blog.csdnimg.cn/20200505134203409.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 3.1.9.5 几个小细节

![](https://img-blog.csdnimg.cn/20200505144046207.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

#### 3.1.10 基本分段存储管理（段表、地址变换、信息共享）

##### 3.1.10.1 总览

![](https://img-blog.csdnimg.cn/20200507133912687.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200507133353133.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 3.1.10.2 什么是分段？

![](https://img-blog.csdnimg.cn/20200507142504777.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

- 分段的[逻辑地址](https://so.csdn.net/so/search?q=逻辑地址&spm=1001.2101.3001.7020)结构

![](https://img-blog.csdnimg.cn/20200507143112191.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 3.1.10.3 段表

![](https://img-blog.csdnimg.cn/20200507143835462.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 3.1.10.4 地址变换

![](https://img-blog.csdnimg.cn/20200507144834316.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 3.1.10.5 分段、分页管理的对比

![](https://img-blog.csdnimg.cn/20200507145814456.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200507151524501.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

###### 分段实现信息共享共享

![](https://img-blog.csdnimg.cn/20200507150216415.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

###### 为什么分页不方便实现信息共享和保护？

![](https://img-blog.csdnimg.cn/20200507151254763.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

#### 3.1.11 段页式存储管理（段表、页表、地址转换、）

##### 3.1.11.1 总览

![](https://img-blog.csdnimg.cn/20200507152253131.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200507154258573.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 3.1.11.2 分页、分段的优缺点分析

![](https://img-blog.csdnimg.cn/20200507153829103.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200507153921773.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 3.1.11.3 分段+分页=段页式管理

![](https://img-blog.csdnimg.cn/20200507154133960.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

###### 段页式管理的[逻辑地址](https://so.csdn.net/so/search?q=逻辑地址&spm=1001.2101.3001.7020)结构

![](https://img-blog.csdnimg.cn/20200507154755703.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

###### 段页式存储的段表、页表

![](https://img-blog.csdnimg.cn/20200507160703773.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 3.1.11.4 段页式管理的[地址转换](https://so.csdn.net/so/search?q=地址转换&spm=1001.2101.3001.7020)过程

![](https://img-blog.csdnimg.cn/20200507161208162.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

#### 习题

### 3.2 虚拟内存管理

#### 3.2.1 虚拟内存的基本概念（局部性原理、高速缓存、虚拟内存的实现）

##### 3.2.1.1 总览

![](https://img-blog.csdnimg.cn/20200507174826507.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200507174915455.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200507175205716.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 3.2.1.2 传统存储管理的特征、缺点

![](https://img-blog.csdnimg.cn/20200507175726392.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 3.2.1.3 局部性原理

![](https://img-blog.csdnimg.cn/20200507180621142.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 3.2.1.4 [虚拟内存](https://so.csdn.net/so/search?q=虚拟内存&spm=1001.2101.3001.7020)的定义和特征

![](https://img-blog.csdnimg.cn/20200507180934242.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200507181109721.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 3.2.1.5 如何实现虚拟内存技术

![](https://img-blog.csdnimg.cn/20200507181418228.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

#### 3.2.2 请求分页管理方式（请求页表、缺页中断机构、地址变换机构）

##### 3.2.2.1 总览

![](https://img-blog.csdnimg.cn/2020050718275041.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/2020050718242973.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 3.2.2.2 [页表](https://so.csdn.net/so/search?q=页表&spm=1001.2101.3001.7020)机制—请求页表与基本页表的区别

![](https://img-blog.csdnimg.cn/20200507183231700.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 3.2.2.3 [缺页中断](https://so.csdn.net/so/search?q=缺页中断&spm=1001.2101.3001.7020)机构

![](https://img-blog.csdnimg.cn/20200507185201230.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200507184941487.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200507185905607.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/2020050719010754.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200507220913997.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 3.2.2.4 地址变换机构

![](https://img-blog.csdnimg.cn/20200507221140511.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/2020050722145316.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200507222657919.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200507222739960.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

#### 3.2.3 页面置换算法

- 最佳置换算法
- 先进先出置换算法
- 最近最久未使用置换算法
- 普通时钟置换算法、改造型时钟置换算法

##### 3.2.3.1 总览

![](https://img-blog.csdnimg.cn/2020050815430075.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200508164532762.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 3.2.3.2 最佳置换算法—OPT

> 不可能实现，纯纯的上帝视角

![](https://img-blog.csdnimg.cn/20200508154738464.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200508155059159.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 3.2.3.3 先进先出置换算法—[FIFO](https://so.csdn.net/so/search?q=FIFO&spm=1001.2101.3001.7020)

![](https://img-blog.csdnimg.cn/20200508155429175.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200508155751826.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 3.2.3.4 最近最久未使用置换算法—LRU

![](https://img-blog.csdnimg.cn/20200508160546901.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200508160702605.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200508160751452.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 3.2.3.5 时钟置换算法—CLOCK

![](https://img-blog.csdnimg.cn/20200508161527270.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200508161856209.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200508162122576.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 3.2.3.6 改造型时钟置换算法

- **只需一轮：**

  ![](https://img-blog.csdnimg.cn/20200508163111666.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

- **需要两轮：**

  ![](https://img-blog.csdnimg.cn/20200508163620613.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

- **需要三轮：**

  ![](https://img-blog.csdnimg.cn/20200508163834664.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

  ![](https://img-blog.csdnimg.cn/20200508164014937.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

- **需要四轮：**

  ![](https://img-blog.csdnimg.cn/20200508164118342.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

  ![](https://img-blog.csdnimg.cn/20200508164207831.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

  ![](https://img-blog.csdnimg.cn/20200508164330498.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

  ![](https://img-blog.csdnimg.cn/20200508164453588.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

#### 3.2.4 页面分配策略（驻留集、页面分配、置换策略、抖动现象、工作集）

##### 3.2.4.1 总览

![](https://img-blog.csdnimg.cn/20200508170637989.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200508170109170.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 3.2.4.2 驻留集

![](https://img-blog.csdnimg.cn/20200508171207873.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 3.2.4.3 页面分配、置换策略

![](https://img-blog.csdnimg.cn/20200508171838609.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

- 固定分配局部置换、可变分配局部置换、可变分配全局置换

![](https://img-blog.csdnimg.cn/20200508172855194.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200508172936378.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 3.2.4.4 何时调入页面？

![](https://img-blog.csdnimg.cn/20200508173243782.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 3.2.4.5 从何处调页？

![](https://img-blog.csdnimg.cn/20200508173648546.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200508173856601.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200508173942434.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 3.2.4.6 抖动（颠簸）现象

![](https://img-blog.csdnimg.cn/20200508174328925.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 3.2.4.7 工作集

![](https://img-blog.csdnimg.cn/20200508174621232.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

#### 习题

## 第 4 章 文件管理

### 4.1 文件系统

#### 4.1.1 初识文件管理概念和功能

##### 4.1.1.1 总览

>文件――就是一组有意义的信息 / 数据集合

![](https://img-blog.csdnimg.cn/20200522115410539.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200522115003361.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 4.1.1.2 文件的属性

![](https://img-blog.csdnimg.cn/20200522115537639.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200522120344485.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

> 同一目录下不允许有重名文件

##### 4.1.1.3 文件内部的数据如何组织起来？

![](https://img-blog.csdnimg.cn/20200522120716806.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

> 无结构文件（如文本文件）――由一些**二进制或字符流**组成，又称“流式文件”
>
> 有结构文件（如数据库表）——由一组**相似的记录**组成，又称“记录式文件”
>
> 数据项是文件系统中最基本的数据单位
>
> 记录是一组相关数据项的集合

![](https://img-blog.csdnimg.cn/20200522120818789.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 4.1.1.4 文件之间应该如何组织起来？

![](https://img-blog.csdnimg.cn/20200522121140364.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

>用户可以自己创建一层一层的目录，各层目录中存放相应的文件。系统中的各个文件就通过一层一层的目录合理有序的组织起
>来了

##### 4.1.1.5 操作系统应该向上提供哪些功能？

![](https://img-blog.csdnimg.cn/20200522121606452.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

> 读 / 写文件之前，需要“打开文件”
>
> 读 / 写文件结束之后，需要“关闭文件”
>
> 可用几个基本操作完成更复杂的操作，比如：“复制文件”；先创建一个新的空文件，再把源文件读入内存，再将内存中的数据写到新文件中

![](https://img-blog.csdnimg.cn/20200522121511583.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 4.1.1.6 从上往下看，文件应该如何存放在外存？

![](https://img-blog.csdnimg.cn/20200522122305784.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

>操作系统以“块”为单位为文件分配存储空间，因此即使一个文件大小只有10B，但它依然需要占用1KB的磁盘块。外存中的数据读入内存时同样以块为单位
>
>类似于内存分为一个个“内存块”，外存会分为一个个“块/磁盘块/物理块”。每个磁盘块的大小是相等的，每块一般包含2的整数幂个地址（如本例中，一块包含`2^10`个地址，即1KB）。同样类似的是，文件的逻辑地址也可以分为（逻辑块号，块内地址），操作系统同样需要将逻辑地址转换为外存的物理地址（物理块号，块内地址）的形式。块内地址的位数取决于磁盘块的大小
>
>与内存一样，外存也是由一个个存储单元组成的，每个存储单元可以存储一定量的数据（如1B）。每个存储单元对应一个物理地址

![](https://img-blog.csdnimg.cn/2020052212231748.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 4.1.1.7 其他需要由操作系统实现的文件管理功能

![](https://img-blog.csdnimg.cn/20200522122522108.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

> 文件共享：使多个用户可以共享使用一个文件
>
> 文件保护：如何保证不同的用户对文件有不同的操作权限

#### 4.1.2 文件逻辑结构

顺序文件、索引文件、索引顺序文件、多级索引顺序文件

> 关于数据库的索引如聚簇索引可以看一下索引文件例题的解析，感觉还是可以收获到东西的

##### 4.1.2.1 总览

![](https://img-blog.csdnimg.cn/20200522125139218.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200522123942803.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 4.1.2.2 无结构文件

>按文件是否有结构分类，可以分为无结构文件、有结构文件两种。
>
>**无结构文件**：文件内部的数据就是一系列二进制流或字符流组成。又称“**流式文件**”。如：Windows操作系统中的.txt文件。

![](https://img-blog.csdnimg.cn/20200522125416464.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 4.1.2.3 有结构文件

> **有结构文件**：由一组相似的记录组成，又称“**记录式文件**”。每条记录又若干个数据项组成。如：数据库表文件。一般来说，每条记录有一个数据项可作为**关键字**（作为识别不同记录的ID）

![](https://img-blog.csdnimg.cn/20200522125958983.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

**定长记录：**

> 根据各条记录的长度（占用的存储空间）是否相等，又可分为定长记录和可变长记录两种。

![](https://img-blog.csdnimg.cn/20200522130030787.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

**不定长记录：**

![](https://img-blog.csdnimg.cn/20200522130046120.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

###### 有结构文件的逻辑结构

> 根据有结构文件中的各条记录在逻辑上如何组织，可以分为三类

![](https://img-blog.csdnimg.cn/20200522130204569.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

###### 顺序文件

> 顺序文件：文件中的记录一个接一个地按顺序排列（逻辑上），记录可以是**定长**的或可变长的。各个记录在物理上可以**顺序存储**或**链式存储**。
>
> 顺序存储――逻辑上相邻的记录物理上也相邻（类似于顺序表）
>
> 链式存储――逻辑上相邻的记录物理上不一定相邻（类似于链）

![](https://img-blog.csdnimg.cn/20200522130936736.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

> 串结构：记录之间的顺序与关键字无关，通常按照记录存入的时间决定记录的顺序
>
> 顺序结构：记录之间的顺序按关键字顺序排序

![](https://img-blog.csdnimg.cn/20200522131914765.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

> 链式存储
>
> - > 无论是定长/可变长记录，都无法实现随机存取，每次只能从第一个记录开始依次往后查找
>
> 顺序存储
>
> - 可变长记录
>
>   - > 无法实现随机存取。每次只能从第一个记录开始依次往后查找
>
> - 定长记录
>
>   - > 可实现随机存取。记录长度为L，则第i个记录存放的相对位置是i * L
>
>   - >若采用串结构，无法快速找到某关键字对应的记录
>
>   - >若采用顺序结构，可以快速找到某关键字对应的记录（如折半查找）

> 结论：定长记录的顺序文件，若物理上采用顺序存储，则可实现随机存取；若能再保证记录的顺序结构，则可实现快速检索（即根据关键字快速找到对应记录）
>
> 注：一般来说，考试题目中所说的“顺序文件”指的是物理上顺序存储的顺序文件。之后的讲解中提到的顺序文件也默认如此。可见，顺序文件的缺点是增加 / 删除一个记录比较困难（如果是串结构则相对简单）

###### 索引文件

- 不经意间让我想起了数据库的索引，聚簇索引和唯一索引等，有了更进一步的理解，而且知道了它的时间空间效率

![](https://img-blog.csdnimg.cn/20200522132434390.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

>**索引表**本身是**定长记录的顺序文件**。因此可以快速找到第i个记录对应的索引项。
>
>可将关键字作为索引号内容，若按关键字顺序排列，则还可以支持按照关键字折半查找。
>
>每当要增加/删除一个记录时，需要对索引表进行修改。由于索引文件有很快的检索速度，因此**主要用于对信息处理的及时性要求比较高的场合**。

###### 索引顺序文件

![](https://img-blog.csdnimg.cn/20200522133637290.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

> 索引顺序文件的索引项也不需要按关键字顺序排列，这样可以极大地方便新表项的插入
>
> 索引顺序文件是索引文件和顺序文件思想的结合。索引顺序文件中，同样会为文件建立一张索引表，但不同的是：并不是每个记录对应一个索引表项，而是一组记录对应一个索引表项。

**索引顺序文件的效率分析：**

![](https://img-blog.csdnimg.cn/2020052213391568.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

###### 多级索引顺序文件

![](https://img-blog.csdnimg.cn/20200522135535103.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

#### 4.1.3 文件目录目录结构

单级-两级-多级-无环图、索引节点FCB瘦身

##### 4.1.3.1 总览

![](https://img-blog.csdnimg.cn/20200523124106644.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200523123856965.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 4.1.3.2 文件控制块

![](https://img-blog.csdnimg.cn/20200523124405301.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

> 目录本身就是一种有结构文件，由一条条记录组成。每条记录对应一个在该放在该目录下的文件
>
> 当我们双击“照片”后，操作系统会在这个目录表中找到关键字“照片”对应的目录项（也就是记录），然后从外存中将“照片”目录的信息读入内存，于是，“照片”目录中的内容就可以显示出来了

![](https://img-blog.csdnimg.cn/2020052312442785.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

>FCB的有序集合称为“文件目录”，一个FCB就是一个文件**目录项**。FCB中包含了文件的**基本信息**（**文件名**、**物理地址**、逻辑结构、物理结构等），存取控制信息（是否可读/可写、禁止访问的用户名单等），使用信息（如文件的建立时间、修改时间等）。
>
>**最重要**，**最基本**的还是**文件名、文件存放的物理地址**。

###### 对目录的操作

![](https://img-blog.csdnimg.cn/20200523124844762.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

>**搜索**：当用户要使用一个文件时，系统要根据文件名搜索目录，找到该文件对应的目录项
>
>**创建文件**：创建一个新文件时，需要在其所属的目录中增加一个目录项
>
>**删除文件**：当删除一个文件时，需要在目录中删除相应的目录项
>
>**显示目录**：用户可以请求显示目录的内容，如显示该目录中的所有文件及相应属性
>
>**修改目录**：某些文件属性保存在目录中，因此这些属性变化时需要修改相应的目录项（如：文件重命名）

##### 4.1.3.3 单级目录结构

![](https://img-blog.csdnimg.cn/20200523125322687.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

>显然，单级目录结构不适用于多用户操作系统（不同用户可能命名相同的文件名）

##### 4.1.3.4 两级目录结构

>早期的多用户操作系统，采用两级目录结构。分为**主文件目录**（MFD，Master File Directory）和**用户文件目录**（UFD，User Flie Directory ）。

![](https://img-blog.csdnimg.cn/20200523125523952.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

> **主文件目录**记录用户名及相应用户文件目录的存放位置
>
> **用户文件目录**由该用户的文件FCB组成
>
> **允许不同用户的文件重名**。文件名虽然相同，但是对应的其实是不同的文件
>
> 两级目录结构允许不同用户的文件重名，也可以在目录上实现实现访问限制（检查此时登录的用户名是否匹配）。但是两级目录结构依然缺乏灵活性，用户不能对自己的文件进行分类

##### 4.1.3.5 多级目录结构(树形目录结构)

![](https://img-blog.csdnimg.cn/20200523130042443.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200523130059174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

**无环图目录结构解决文件共享**

![](https://img-blog.csdnimg.cn/20200523130246757.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

> **树形目录结构**可以很方便地对文件进行分类，层次结构清晰，也能够更有效地进行文件的管理和保护。但是，树形结构**不便于实现文件的共享**。为此，提出了“**无环图目录结构**”。

##### 4.1.3.6 无环图目录结构

![](https://img-blog.csdnimg.cn/20200523130642259.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

> 在树形目录结构的基础上，增加一些指向同一节点的有向边，使整个目录成为一个**有向无环图**。可以更方便地实现多个用户间的文件共享

>**可以用不同的文件名指向同一个文件**，甚至可以指向同一个目录（共享同一目录下的所有内容）
>
>需要为**每个共享结点设置一个共享计数器**，用于记录此时有多少个地方在共享该结点。用户提出删除结点的请求时，只是删除该用户的FCB、并使**共享计数器减1**，并不会直接删除共享结点

![](https://img-blog.csdnimg.cn/20200523130734762.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

>**可以用不同的文件名指向同一个文件**，甚至可以指向同一个目录（共享同一目录下的所有内容)。
>
>需要为**每个共享结点设置一个共享计数器**，用于记录此时有多少个地方在共享该结点。用户提出删除结点的请求时，只是删除该用户的FCB、并使**共享计数器减1**，并不会直接删除共享结点。
>
>**只有共享计数器减为0时，才删除结点。**
>
>注意：共享文件不同于复制文件。在**共享文件中，由于各用户指向的是同一个文件，因此只要其中一个用户修改了文件数据，那么所有用户都可以看到文件数据的变化。**

##### 4.1.3.7 [索引](https://so.csdn.net/so/search?q=索引&spm=1001.2101.3001.7020)节点(FCB的改进)瘦身

![](https://img-blog.csdnimg.cn/20200523131601605.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

> 索引结点——除了文件名之外的文件描述信息都放到这里来
>
> 其实在查找各级目录的过程中只需要用到“文件名”这个信息，只有文件名匹配时，才需要读出文件的其他信息。因此可以考虑让目录表“瘦身”来提升效率。

![](https://img-blog.csdnimg.cn/20200523132037806.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

> 当找到文件名对应的目录项时，才需要将索引结点调入内存，索引结点中记录了文件的各种信息，包括文件在外存中的存放位置，根据“存放位置”即可找到文件。
>
> 存放**在外存中**的索引结点称为“**磁盘索引结点**”，当索引结点**放入内存**后称为“**内存索引结点**”。
>
> 相比之下**内存索引结点中需要增加一些信息**，比如：文件是否被修改、此时有几个进程正在访问该文件等。

#### 4.1.4 文件的物理结构

连续分配、链接分配[隐式—显式]、索引分配[链接方案—多层索引—混合索引]

##### 4.1.4.1 总览

![](https://img-blog.csdnimg.cn/20200523175810192.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200523175944306.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 4.1.4.2 文件块、磁盘块

![](https://img-blog.csdnimg.cn/20200523180224299.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200523180541535.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

>在内存管理中，进程的逻辑地址空间被分为一个一个页面
>
>同样的，在外存管理中，为了方便对文件数据的管理，**文件的逻辑地址空间也被分为了一个一个的文件“块”**。
>
>于是文件的逻辑地址也可以表示为**（逻辑块号，块内地址）**的形式。

##### 4.1.4.3 连续分配

**连续分配优点：**

![](https://img-blog.csdnimg.cn/20200523181027428.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

**连续分配缺点：**

> 连续分配方式要求**每个文件在磁盘上占有一组连续的块**。

![](https://img-blog.csdnimg.cn/20200526121328529.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

> 结论：物理上采用连续分配的文件不方便拓展。

![](https://img-blog.csdnimg.cn/20200526121531193.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

>结论：物理上采用连续分配，存储空间利用率低，会产生难以利用的磁盘碎片
>
>可以用紧凑来处理碎片，但是需要耗费很大的时间代价。

##### 4.1.4.4 链接分配

> 链接分配采取离散分配的方式，可以为文件分配离散的磁盘块。分为**隐式链接**和**显式链接**两种。

![](https://img-blog.csdnimg.cn/20200526122103375.png)

###### 隐式链接

![](https://img-blog.csdnimg.cn/20200526122521818.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

> 结论：采用**链式分配（隐式链接）**方式的文件，**只支持顺序访问，不支持随机访问**，查找效率低。另外，指向下一个盘块的指针也需要耗费少量的存储空间。

![](https://img-blog.csdnimg.cn/20200526122627253.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

> 结论：采用隐式链接的**链接分配方式，很方便文件拓展**。另外，所有的空闲磁盘块都可以被利用，**不会有碎片问题，外存利用率高。**

###### 显式链接

> 把用于链接文件各物理块的指针显式地存放在一张表中。即文件分配表（FAT，File Allocation Table)

![](https://img-blog.csdnimg.cn/20200526123107715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

> **注意：一个磁盘仅设置一张FAT。开机时，将FAT读入内存，并常驻内存。**FAT的各个表项在物理上连续存储，且每一个表项长度相同，因此“物理块号”字段可以是隐含的。

![](https://img-blog.csdnimg.cn/20200526123940106.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

>从目录项中找到起始块号，若i > 0，则查询内存中的文件分配表FAT，往后找到i号逻辑块对应的物理块号。**逻辑块号转换成物理块号的过程不需要读磁盘操作。**
>
>结论：采用**链式分配（显式链接）**方式的文件，支持顺序访问，也**支持随机访问（想访问 i 号逻辑块时，并不需要依次访问之前的0 ~ i-1号逻辑块）**，由于块号转换的过程不需要访问磁盘，因此相比于隐式链接来说，访问速度快很多。
>
>显然，显式链接也**不会产生外部碎片，也可以很方便地对文件进行拓展**。

###### 链接分配总结

![](https://img-blog.csdnimg.cn/20200526124219255.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

>**链接分配**采取离散分配的方式，可以为文件分配离散的磁盘块。分为**隐式链接**和**显式链接**两种。
>
>- 隐式链接――除文件的最后一个盘块之外，每个盘块中都存有指向下一个盘块的指针。文件目录包括文件第一块的指针和最后一块的指针。
>  - 优点：很方便文件拓展，不会有碎片问题，外存利用率高。
>  - 缺点：只支持顺序访问，不支持随机访问，查找效率低，指向下一个盘块的指针也需要耗费少量的存储空间。
>- 显式链接――把用于链接文件各物理块的指针显式地存放在一张表中，即**文件分配表**（FAT，FileAllocation Table)。一个磁盘只会建立一张文件分配表。开机时文件分配表放入内存，并**常驻内存**。
>  - 优点：很方便文件拓展，不会有碎片问题，外存利用率高，并且**支持随机访问**。相比于隐式链接来说，**地址转换时不需要访问磁盘，因此文件的访问效率更高。**
>  - 缺点：文件分配表的需要占用一定的存储空间。

##### 4.1.4.5 [索引](https://so.csdn.net/so/search?q=索引&spm=1001.2101.3001.7020)分配

> 索引分配允许文件离散地分配在各个磁盘块中，系统会**为每个文件建立一张索引表**，索引表中**记录了文件的各个逻辑块对应的物理块**（索引表的功能类似于内存管理中的页表――建立逻辑页面到物理页之间的映射关系）。索引表存放的磁盘块称为**索引块**。文件数据存放的磁盘块称为**数据块**。

![](https://img-blog.csdnimg.cn/20200526214653473.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

**如何实现逻辑块号到物理块号的转换？**

![](https://img-blog.csdnimg.cn/2020052621502668.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

> 可见，**索引分配方式可以支持随机访问。文件拓展也很容易实现**（只需要给文件分配一个空闲块，并增加一个索引表项即可）但是**索引表需要占用一定的存储空间**

**数据太大，一个索引表装不下那么多的映射怎么办？**

![](https://img-blog.csdnimg.cn/2020052621523779.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

###### 链接方案

> 如果索引表太大，一个索引块装不下，那么可以将多个索引块链接起来存放。

![](https://img-blog.csdnimg.cn/20200526215650573.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

###### 多层索引

> 建立多层索引（原理类似于多级页表）。使第一层索引块指向第二层的索引块，还可根据文件大小的要求再建立第三层、第四层索引块。

![](https://img-blog.csdnimg.cn/20200526220231437.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200526220247377.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

###### 混合索引

> 多种索引分配方式的结合。例如：一个文件的顶级索引表中，既包含**直接地址索引**（直接指向**数据块**），又包含**一级间接索引**（指向单层索引表）、还包含**两级间接索引**（指向两层索引表）。

![](https://img-blog.csdnimg.cn/20200526221016186.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

###### 索引分配总结

![](https://img-blog.csdnimg.cn/20200526222046139.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

>索引分配允许文件离散地分配在各个磁盘块中，系统会**为每个文件建立一张索引表**，索引表中**记录了文件的各个逻辑块对应的物理块**（索引表的功能类似于内存管理中的页表――建立逻辑页面到物理页之间的映射关系）。索引表存放的磁盘块称为**索引块**，文件数据存放的磁盘块称为**数据块**。
>
>若文件太大，索引表项太多，可以采取以下三种方法解决:
>
>①**链接方案**：如果索引表太大，一个索引块装不下，那么可以将多个索引块链接起来存放。**缺点**：若文件很大，索引表很长，就需要将很多个索引块链接起来。想要找到i号索引块，必须先依次读入0 ~ i-1号索引块，这就导致磁盘I/O次数过多，查找效率低下。
>
>②**多层索引**：建立多层索引（**原理类似于多级页表**）。使第一层索引块指向第二层的索引块。还可根据文件大小的要求再建立第三层、第四层索引块。采用K层索引结构，且**顶级索引表未调入内存**，则访问一个数据块只需要K+1次读磁盘操作。**缺点**：即使是小文件，访问一个数据块依然需要K+1次读磁盘。
>
>③**混合索引**：多种索引分配方式的结合。例如，一个文件的顶级索引表中，既包含**直接地址索引**（直接指向数据块），又包含**一级间接索引**（指向单层索引表)、还包含两级间接索引（指向两层索引表)。**优点**：对于小文件来说，访问一个数据块所需的读磁盘次数更少。
>
>**超级超级超级重要考点**：①要会根据多层索引、混合索引的结构计算出文件的最大长度（**Key**：各级索引表最大不能超过一个块）；②要能自己分析访问某个数据块所需要的读磁盘次数（**Key**：FCB中会存有指向顶级索引块的指针，因此可以根据FCB读入顶级索引块。每次读入下一级的索引块都需要一次读磁盘操作。另外，要注意**题目条件――顶级索引块是否已调入内存**）

##### 4.1.4.6 文件物理结构分配总结

![](https://img-blog.csdnimg.cn/2020052622231856.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

#### 4.1.5 文件管理空闲磁盘块的几种算法

- 空闲表法、空闲链表法、位示图法、成组链接法

##### 4.1.5.1 总览

![](https://img-blog.csdnimg.cn/20200527093003300.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200527093031972.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200527092827428.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 4.1.5.2 存储空间的划分与初始化

> 安装Windows操作系统的时候，一个必经步骤是――为磁盘分区（C:盘、D:盘、E:盘等)
>
> 存储空间的划分：将物理磁盘划分为一个个文件卷（逻辑卷、逻辑盘）
>
> 有的系统支持超大型文件，可支持由多个物理磁盘组成一个文件卷

![](https://img-blog.csdnimg.cn/20200527093405314.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

> 目录区主要存放文件目录信息（FCB）、用于磁盘存储空间管理的信息
>
> 存储空间的初始化：将各个文件卷划分为目录区、文件区
>
> 文件区用于存放文件数据

##### 4.1.5.3 空闲表法

> 适用于“连续分配方式”

**如何分配？**

![](https://img-blog.csdnimg.cn/20200527093815258.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200527093847994.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

> 如何分配磁盘块：与内存管理中的动态分区分配很类似，为一个文件**分配连续的存储空间**。同样**可采用首次适应、最佳适应、最坏适应等算法**来决定要为文件分配哪个区间。

**如何回收？**

![](https://img-blog.csdnimg.cn/2020052709424132.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

> ==如何回收磁盘块==：与内存管理中的动态分区分配很类似，当回收某个存储区时需要有四种情况——①回收区的前后都没有相邻空闲区；②回收区的前后都是空闲区；③回收区前面是空闲区；④回收区后面是空闲区。**总之，回收时需要注意表项的合开问题。**

![](https://img-blog.csdnimg.cn/20200527094303480.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 4.1.5.4 空闲[链表](https://so.csdn.net/so/search?q=链表&spm=1001.2101.3001.7020)法

>空闲盘块链——以==盘块==为单位组成一条空闲链——空闲盘块中存储着下一个空闲盘块的指针
>
>空闲盘区链——以==盘区==为单位组成一条空闲链——空闲盘区中的第一个盘块内记录了盘区的长度、下一个盘区的指针

![](https://img-blog.csdnimg.cn/20200527094753210.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

###### 空闲盘块链

> 操作系统保存着**链头、链尾指针**
>
> 如何分配：若某文件申请K个盘块，则从链头开始依次摘下K个盘块分配，并修改空闲链的链头指针
>
> 如何回收：回收的盘块依次挂到链尾，并修改空闲链的链尾指针
>
> > 适用于离散分配的物理结构，为文件分配多个盘块时可能要重复多次操作

![](https://img-blog.csdnimg.cn/20200527095006531.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

###### 空闲盘区链

> 如何分配：若某文件申请K个盘块，则可以采用首次适应、最佳适应等算法，从链头开始检索，按照算法规则找到一个大小符合要求的空闲盘区，分配给文件。若没有合适的连续空闲块，也可以将不同盘区的盘块同时分配给一个文件，注意分配后可能要修改相应的链指针、盘区大小等数据。
>
> 如何回收：若回收区和某个空闲盘区相邻，则需要将回收区合并到空闲盘区中。若回收区没有和任何空闲区相邻，将回收区作为单独的一个空闲盘区挂到链尾。
>
> > 离散分配、连续分配都适用。为一个文件分配多个块时效率更高

![](https://img-blog.csdnimg.cn/20200527095454861.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 4.1.5.5 [位示图](https://so.csdn.net/so/search?q=位示图&spm=1001.2101.3001.7020)法

![](https://img-blog.csdnimg.cn/20200527101205324.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

**如何分配与回收？**

![](https://img-blog.csdnimg.cn/20200527101457195.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 4.1.5.6 成组链接法

![](https://img-blog.csdnimg.cn/20200527101656406.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

**超级块的作用**

![](https://img-blog.csdnimg.cn/20200527102209635.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

**如何分配？**
**需要1个空闲磁盘块**

![](https://img-blog.csdnimg.cn/20200527102615871.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200527102650454.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

**需要100个空心啊磁盘块**

![](https://img-blog.csdnimg.cn/20200527103152826.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200527103420187.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

**如何回收？**

![](https://img-blog.csdnimg.cn/20200527103743514.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200527103846181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

**第二种情况，第一组已满**

![](https://img-blog.csdnimg.cn/20200527104150950.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200527104331995.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

#### 4.1.6 文件的基本操作原理

- 创建、删除、打开、关闭、读-写

##### 4.1.6.1 总览

![](https://img-blog.csdnimg.cn/20200527105500130.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200527105538537.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 4.1.6.2 创建文件

>1.在外存中找到文件所需的空间（结合上小节学习的空闲链表法、位示图、成组链接法等管理策略，找到空闲空间）
>
>2.根据文件存放路径的信息找到该目录对应的目录文件（此处就是D:/Demo目录），在目录中创建该文件对应的目录项。目录项中包含了文件名、文件在外存中的存放位置等信息

![](https://img-blog.csdnimg.cn/20200527105909485.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 4.1.6.3 删除文件

>1.根据文件存放路径找到相应的目录文件，从目录中找到文件名对应的目录项
>
>2.根据该目录项记录的文件在外存的存放位置、文件大小等信息，回收文件占用的磁盘块（回收磁盘块时，根据空闲表法、空闲链表法、位图法等管理策略的不同，需要做不同的处理）
>
>3.从目录表中删除文件对应的影录项

![](https://img-blog.csdnimg.cn/20200527110143365.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 4.1.6.4 打开文件

>1.根据文件存放路径找到相应的目录文件，从目录中找到文件名对应的的目录项，并检查该用户是否有指定的操作权限。
>
>2.将目录项复制到内存中的“打开文件表”中。并将对应表目的编号返回给用户。之后用户使用打开文件表的编号来指明要操作的文件。

![](https://img-blog.csdnimg.cn/20200527111254846.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

**打开文件表有两种：**

![](https://img-blog.csdnimg.cn/20200527111717779.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 4.1.6.5 关闭文件

>1.将进程的打开文件表相应表项删除
>
>2.回收分配给该文件的内存空间等资源
>
>3.系统打开文件表的打开计数器count减1，若count = 0，则删除对应表项。

![](https://img-blog.csdnimg.cn/2020052711193590.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 4.1.6.6 读文件

![](https://img-blog.csdnimg.cn/20200527112223684.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 4.1.6.7 写文件

![](https://img-blog.csdnimg.cn/20200527112538798.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

#### 4.1.7 文件共享

- 索引节点——硬链接、符号链接——软链接

##### 4.1.7.1 总览

>操作系统为用户提供文件共享功能，可以让多个用户共享地使用同一个文件

![](https://img-blog.csdnimg.cn/202005271135124.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

>注意：多个用户共享同一个文件，意味着系统中只有“一份”文件数据。并且只要某个用户修改了该文件的数据，其他用户也可以看到文件数据的变化。
>
>如果是多个用户都“复制”了同一个文件，那么系统中会有“好几份”文件数据。其中一个用户修改了自己的那份文件数据，对其他用户的文件数据并没有影响。

![](https://img-blog.csdnimg.cn/20200527115516907.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 4.1.7.2 基于索引结点的共享方式（[硬链接](https://so.csdn.net/so/search?q=硬链接&spm=1001.2101.3001.7020)）

> 知识回顾：索引结点，是一种文件目录瘦身策略。由于检索文件时只需用到文件名，因此可以将除了文件名之外的其他信息放到索引结点中。这样目录项就只需要包含文件名、索引结点指针

![](https://img-blog.csdnimg.cn/20200527114037150.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 4.1.7.3 基于符号链的共享方式（软链接）

![](https://img-blog.csdnimg.cn/20200527114710627.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

**例子**

![](https://img-blog.csdnimg.cn/20200527114812634.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/2020052711483689.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

**共享的文件不存在时**

![](https://img-blog.csdnimg.cn/20200527115248717.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200527115322484.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200527115343225.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

#### 4.1.8 文件保护（口令保护、加密保护、访问控制）

##### 4.1.8.1 总览

![](https://img-blog.csdnimg.cn/20200527163358429.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

> 访问控制：如果对某个目录进行了访问权限的控制，那也要对目录下的所有文件进行相同的访问权限控制（爸爸被管了，儿子也要被管）

##### 4.1.8.2 口令保护

![](https://img-blog.csdnimg.cn/20200527163541414.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

> 口令一般存放在文件对应的FCB或索引结点中。用户访问文件前需要先输入“口令”，操作系统会将用户提供的口令与FCB中存储的口令进行对比，如果正确，则允许该用户访问文件
>
> 优点：保存口令的空间开销不多，验证口令的时间开销也很小
>
> 缺点：正确的“口令”存放在系统内部，不够安全

##### 4.1.8.3 [加密](https://so.csdn.net/so/search?q=加密&spm=1001.2101.3001.7020)保护

> 使用某个“密码”对文件进行加，在访问文件时需要提供正确的“密码”才能对文件进行正确的解密

![](https://img-blog.csdnimg.cn/20200527173742520.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 4.1.8.4 访问控制

> 在每个文件的FCB（或索引结点）中增加一个访问控制列表（Access-Control List,ACL），该表中记录了各个用户可以对该文件执行哪些操作
>
> 有的计算机可能会有很多个用户，因此访问控制列表可能会很大，可以用精简的访问列表解决这个问题

![](https://img-blog.csdnimg.cn/20200527174427303.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200527174808366.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

###### windows的访问控制

![](https://img-blog.csdnimg.cn/20200527175217115.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200527175232337.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200527175245938.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200527175306196.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200527175323435.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

#### 4.1.9 文件系统的层次结构

##### 4.1.9.1 总览

![](https://img-blog.csdnimg.cn/20200527181133755.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

>**用户接口**：文件系统需要向上层的用户提供一些简单易用的功能接口。这层就是用于处理用户发出的系统调用请求（Read、Write、Open、Close等系统调用）
>
>**文件目录系统**：用户是通过文件路径来访问文件的，因此这一层需要根据用户给出的文件路径找到相应的FCB或索引结点。所有和目录、目录项相关的管理工作都在本层完成，如：管理活跃的文件目录表、管理打开文件表等
>
>**存取控制模块**：为了保证文件数据的安全，还需要验证用户是否有访问权限。这一层主要完成了文件保护相关功能
>
>**逻辑文件系统与文件信息缓冲区**：用户指明想要访问文件记录号，这一层需要将记录号转换为对应的逻辑地址
>
>**物理文件系统**：这一层需要把上一层提供的文件逻辑地址转换为实际的物理地址
>
>**辅助分配模块**：负责文件存储空间的管理,即负责分配和回收存储空间
>
>**设备管理模块**：直接与硬件交互，负责和硬件直接相关的一些管理工作。如：分配设备、分配设备缓冲区、磁盘调度、启动设备、释放设备等

##### 举个例子

![](https://img-blog.csdnimg.cn/20200527181400891.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

### 4.2 磁盘组织与管理

#### 4.2.1 磁盘的结构（磁盘、磁道、扇区、盘面、柱面、磁头）

##### 4.2.1.1 总览

![](https://img-blog.csdnimg.cn/20200527182037507.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 4.2.1.2 磁盘、磁道、扇区

>磁盘的表面由一些磁性物质组成，可以用这些磁性物质来记录二进制数据

![](https://img-blog.csdnimg.cn/20200527182515944.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

>磁盘的盘面被划分成一个个磁道，这样的一个“圈就是一个磁道
>
>一个磁道又被划分成一个个扇区，每个扇区就是一个磁盘块”，**各个扇区存放的数据量相同**（如1KB）
>
>最内侧磁道上的扇区面积最小，因此数据密度最大

##### 4.2.1.3 如何在磁盘中读/写数据

>需要把“磁头”移动到想要读/写的扇区所在的磁道。磁盘会转起来，让目标扇区从磁头下面划过，才能完成对扇区的读 / 写操作。

![](https://img-blog.csdnimg.cn/2020052718281993.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 4.2.1.4 盘面、柱面

![](https://img-blog.csdnimg.cn/20200527183213448.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 4.2.1.5 磁盘的分类

###### 按磁头是否可移动分类

> - 磁头可以移动的称为**活动头磁盘**，磁臂可以来回伸缩来带动磁头定位磁道
>
> - 磁头不可移动的称为**固定头磁盘**，这种磁盘中每个磁道有一个磁头

![](https://img-blog.csdnimg.cn/202005271833589.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

###### 按盘片是否可更换分类

>- 盘片可以更换的称为**可换盘磁盘**
>
>- 盘片不可更换的称为**固定盘磁盘**

![](https://img-blog.csdnimg.cn/20200527183434406.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

#### 4.2.2 磁盘调度算法

- FCFS、SSTF、SCAN、LOOK、S-SCAN、C-LOOK

##### 4.2.2.1 总览

![](https://img-blog.csdnimg.cn/20200527183825621.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200527183847708.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 4.2.2.2 一次磁盘读/写操作需要的时间

>寻找时间（寻道时间）：启动磁臂移动磁头所花的时间（磁盘调度算法影响的指标）
>
>延迟时间：将目标扇区转到磁头下面所花的时间
>
>传输时间：读 / 写数据花费的时间

![](https://img-blog.csdnimg.cn/20200527185033126.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200527185119780.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200527185217625.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

> 延迟时间和传输时间都与磁盘转速相关，且为线性相关。而转速是硬件的固有属性，因此操作系统也无法优化延迟时间和传输时间

##### 4.2.2.3 先来先服务（FCFS）

> 根据进程请求访问磁盘的==先后顺序==进行调度

![](https://img-blog.csdnimg.cn/20200527192035648.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

>优点：公平；如果请求访问的磁道比较集中的话，算法性能还算过的去
>
>缺点：如果有大量进程竞争使用磁盘，请求访问的磁道很分散，则FCFS在性能上很差，寻道时间长

##### 4.2.2.4 最短寻找时间优先算法（SSTF）

>SSTF算法会==优先处理的磁道是与当前磁头最近的磁道==。可以保证每次的寻道时间最短但是并不能保证总的寻道时间最短。(其实就是贪心算法的思想，只是选择眼前最优，但是总体未必最优)

![](https://img-blog.csdnimg.cn/20200527192305288.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

> 优点：性能较好，平均寻道时间短
>
> 缺点：可能产生“饥饿”现象
>
> 产生饥饿的原因在于：磁头在一个小区域内来回来去地移动

##### 4.2.2.5 扫描算法（SCAN）

> 只有磁头移动到最外侧磁道的时候才能往内移动，移动到最内侧磁道的时候才能往外移动。这就是扫描算法（SCAN）的思想，由于磁头移动的方式很像电梯，因此也叫电梯算法。

![](https://img-blog.csdnimg.cn/20200527193037761.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

>优点：性能较好，平均寻道时间较短，不会产生饥饿现象
>
>缺点：①只有到达最边上的磁道时才能改变磁头移动方向，事实上，处理了184号磁道的访问请求之后就不需要再往右移动磁头了。②SCAN算法对于各个位置磁道的响应频率不平均（如：假设此时磁头正在往右移动，且刚处理过90号磁道，那么下次处理90号磁道的请求就需要等磁头移动很长一段距离；而响应了184号磁道的请求之后，很快又可以再次响应184号磁道的请求了）

##### 4.2.2.6 LOOK算法

> LOOK调度算法就是为了解决扫描算法的问题，如果在磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向。（边移动边观察，因此叫LOOK）

![](https://img-blog.csdnimg.cn/20200527193300867.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

> 优点：比起SCAN算法来，不需要每次都移动到最外侧或最内侧才改变磁头方向，使寻道时间进一步缩短

##### 4.2.2.7 循环扫描算法（C-SCAN）

>SCAN算法对于各个位置磁道的响应频率不平均，而C-SCAN算法就是为了解决这个问题，规定只有磁头朝某个特定方向移动时才处理磁道访问请求，而**返回时直接快速移动至起始端而不处理任何请求**

![](https://img-blog.csdnimg.cn/2020052719355596.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

>优点：比起SCAN来，对干各个位置磁道的响应频率很平均
>
>缺点：只有到达最边上的磁道时才能改变磁头移动方向，事实上，处理了184号磁道的访问请求之后就不需要再往右移动磁头了；并且，磁头返回时其实只需要返回到18号磁道即可，不需要返回到最边缘的磁道。另外，比起SCAN算法来，平均寻道时间更长

##### 4.2.2.8 C-LOOK算法

> C-SCAN算法的主要缺点是只有到达最边上的磁道时才能改变磁头移动方向，并且磁头返回时不一定需要返回到最边缘的磁道上。C-LOOK算法就是为了解决这个问题。如果磁头移动的方向上已经没有磁道访问请求了，就可以立即让磁头返回，并且磁头只需要返回到有磁道访问请求的位置即可

![](https://img-blog.csdnimg.cn/20200527193744152.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

> 优点：比起C-SCAN算法来，不需要每次都移动到最外侧或最内侧才改变磁头方向，使寻道时间进一步缩短

#### 4.2.3 减少磁盘延迟时间的方法（交替编号、错位命名）

##### 4.2.3.1 总览

![](https://img-blog.csdnimg.cn/20200527200137433.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 4.2.3.2 前情回顾

![](https://img-blog.csdnimg.cn/20200527200118849.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

>结论：磁头读入一个扇区数据后需要一小段时间处理，如果逻辑上相邻的扇区在物理上也相邻，则读入几个连续的逻辑扇区，可能需要很长的“延迟时间”

##### 4.2.3.3 交替编号

> 若采用交替编号的策略，即让逻辑上相邻的扇区在物理上有一定的间隔，可以使读取连续的逻辑扇区所需要的延迟时间更小
>
> 例如在磁头转到0扇区之前已经做好准备，则可以直接读取0号扇区数据

![](https://img-blog.csdnimg.cn/20200527200437737.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 4.2.3.4 磁盘地址结构的设计

![](https://img-blog.csdnimg.cn/20200527201315961.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200527201555821.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200527201952415.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 4.2.3.5 错位命名

![](https://img-blog.csdnimg.cn/20200527202535405.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200527202753151.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

#### 4.2.4 磁盘管理（磁盘初始化、引导块、坏块的管理）

##### 4.2.4.1 总览

![](https://img-blog.csdnimg.cn/20200527203526710.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 4.2.4.2 磁盘初始化

![](https://img-blog.csdnimg.cn/20200527214937558.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

>step 1：进行**低级格式化（物理格式化）**，将磁盘的各个磁道**划分为扇区**。一个扇区通常可分为头、数据区域（如512B大小）、尾三个部分组成。管理扇区所需要的各种数据结构一般存放在头、尾两个部分，包括扇区校验码（如奇偶校验、CRC循环冗余校验码等，校验码用于校验扇区中的数据是否发生错误）
>
>Step 2：将磁盘分区，每个分区由若干柱面组成（即分为我们熟悉的c盘、D盘、E盘）
>
>Step 3：进行**逻辑格式化**，创建文件系统。包括创建文件系统的根目录、初始化存储空间管理所用的数据结构（如位示图、空闲分区表）

##### 4.2.4.3 引导块

![](https://img-blog.csdnimg.cn/20200527215217181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200527215508634.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 4.2.4.4 坏块的管理

![](https://img-blog.csdnimg.cn/20200527220014555.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

## 第 5 章 I/O管理

### 5.1 I/O管理概述

#### 5.1.1 什么是I/O设备？有几类I/O设备？

##### 5.1.1.1 总览

![](https://img-blog.csdnimg.cn/20200515102227914.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 5.1.1.2 什么是I/O设备？

> I/O设备就是可以将数据输入到计算机，或者可以接收计算机输出数据的外部设备，属于计算机中的硬件部件

![](https://img-blog.csdnimg.cn/2020051510273677.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200515102805882.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

> UNIX系统将外部设备抽象为一种特殊的文件，用户可以使用与文件操作相同的方式对外部设备进行操作
>
> Write操作：向外部设备写出数据
>
> Read操作：从外部设备读入数据

##### 5.1.1.3 I/O设备的分类

###### （1）按使用特性分类

![](https://img-blog.csdnimg.cn/20200515103035186.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

>人机交互类外部设备：数据**传输速度慢**，鼠标、键盘、打印机等——用于人机交互
>
>存储设备：数据**传输速度快**，存储设备:移动硬盘、光盘等――用于数据存储
>
>网络通信设备：数据传输速度**介于上述二者之间**，调制解调器等――用于网络通信

###### （2）按传输速率分类

![](https://img-blog.csdnimg.cn/20200515104001796.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

> 低速设备：鼠标、键盘等――传输速率为每秒**几个到几百字节**
>
> 中速设备：如激光打印机等——传输速率为每秒**数千至上万个字节**
>
> 高速设备：如磁盘等——传输速率为每秒**数千字节至千兆字节**

###### （3）按信息交换单位分类

![](https://img-blog.csdnimg.cn/20200515104649817.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

>块设备：传输速率较高，可寻址，即对它可随机地读/写任一块，如磁盘等——数据传输的基本单位是“块”
>
>字符设备：传输速率较慢，不可寻址，在输入/输出时常采用中断驱动方式，鼠标、键盘等——数据传输的基本单位是字符

#### 5.1.2 控制I/O设备的I/O控制器

##### 5.1.2.1 总览

![](https://img-blog.csdnimg.cn/20200515104941387.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 5.1.2.2 I/O设备的组成

> I/O设备由机械部件和电子部件（I/O控制器、设备控制器）组成

![](https://img-blog.csdnimg.cn/20200515105101549.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

###### （1）机械部件

![](https://img-blog.csdnimg.cn/20200515105337450.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

>I/O设备的**机械部件**主要用来执行具体I/O操作。
>		如我们看得见摸得着的鼠标/键盘的按钮；显示器的LED屏；移动硬盘的磁臂、磁盘盘面
>
>I/O设备的**电子部件**通常是一块插入主板扩充槽的印刷电路板。

###### （2）电子部件—I/O控制器的功能

>CPU无法直接控制I/O设备的机械部件，因此I/O设备还要有一个电子部件作为CPU和I/O设备机械部件之间的“中介”，用于实现CPU对设备的控制。
>
>这个电子部件就是**I/O控制器**，又称**设备控制器**。==CPU可控制I/O控制器，又由I/O控制器来控制设备的机械部件。==

![](https://img-blog.csdnimg.cn/20200515110550372.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

> 1. 接受和识别CPU发出的命令
>
> - 如CPU发来的read/write命令，I/O控制器中会有相应的**控制寄存器**来存放命令和参数
>
> 2. 向CPU报告设备的状态
>
> - I/O控制器中会有相应的**状态寄存器**，用于记录I/O设备的当前状态。如：1表示空闲，0表示忙碌
>
> 3. 数据交换
>
> - I/O控制器中会设置相应的**数据寄存器**。输出时，数据寄存器用于暂存CPU发来的数据，之后再由控制器传送设备。输入时，数据寄存器用于暂存设备发来的数据，之后CPU从数据寄存器中取走数据。
>
> 4. 地址识别
>
> - 类似于内存的地址，为了区分设备控制器中的各个寄存器，也需要给各个寄存器设置一个特定的“地址”。I/O控制器通过CPU提供的“地址”来判断CPU要读/写的是哪个寄存器

##### 5.1.2.3 I/O控制器的组成

![](https://img-blog.csdnimg.cn/20200515111916102.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

>*<u>CPU与控制器的接口</u>*：用于实现CPU与控制器之间的通信。CPU通过<u>控制线</u>发出命令；通过<u>地址线</u>指明要操作的设备；通过<u>数据线</u>来取出（输入）数据，或放入（输出）数据
>
>I/O逻辑：负责接收和识别CPU的各种命令（如地址译码）并负责对设备发出命令
>
><u>控制器与设备的接口</u>：用于实现控制器与设备之间的通信

**注意：**

![](https://img-blog.csdnimg.cn/20200515111954968.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

>值得注意的小细节：①一个I/O控制器可能会对应多个设备；②数据寄存器、控制寄存器、状态寄存器可能有多个（如：每个控制/状态寄存器对应一个具体的设备），且这些寄存器都要有相应的地址，才能方便CPU操作。有的计算机会让这些寄存器占用内存地址的一部分，称为**内存映像I/O**；另一些计算机则采用I/O专用地址，即**寄存器独立编址**。

##### 5.1.2.4 I/O控制器的两种[寄存器](https://so.csdn.net/so/search?q=寄存器&spm=1001.2101.3001.7020)编址方式

- [内存](https://so.csdn.net/so/search?q=内存&spm=1001.2101.3001.7020)映像——独立编址

![](https://img-blog.csdnimg.cn/20200515112219587.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

> 内存映像I/O
>
> - 内存映射I/O。控制器中的寄存器与内存地址统编址
> - 优点：简化了指令。可以采用对内存进行操作的指令来对控制器进行操作
>
> 寄存器独立编制
>
> - 寄存器独立编制。控制器中的寄存器使用单独的地址
> - 缺点：需要设置专门的指令来实现对控制器的操作，不仅要指明寄存器的地址，还要指明控制器的编号

#### 5.1.3 控制I/O设备的几种方式？

- 程序直接控制方式、中断驱动方式、DMA、通道控制

##### 5.1.3.1 总览

>I/O控制方式——即用什么样的方式来控制I/O设备的数据read/write

![](https://img-blog.csdnimg.cn/20200515163014385.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 5.1.3.2 程序直接控制方式

**key word：轮询**

- 完成一次读/写操作的流程图（以读操作为例）

![](https://img-blog.csdnimg.cn/20200515164145475.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

> ①CPU向控制器发出读指令。于是设备启动，并且状态寄存器设为1（未就绪）
>
> ②轮询检查控制器的状态（其实就是在不断地执行程序的循环，若状态位一直是1，说明设备还没准备好要输入的数据，于是CPU会不断地轮询）一直等到接受到设备发送的响应（如响应导致的状态位发生变化）
>
> ③输入设备准备好数据后将数据传给控制器，并报告自身状态
>
> ④控制器将输入的数据放到数据寄存器中，并将状态改为0（已就绪）
>
> ⑤CPU发现设备已就绪，即可将数据寄存器中的内容读入CPU的寄存器中，再把CPU寄存器中的内容放入内存
>
> ⑥若还要继续读入数据，则CPU继续发出读指令

> **下面以C语言代码和流程图来剖析，程序直接控制方式**

![](https://img-blog.csdnimg.cn/20200515164832257.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

> **分析一下在思维导图中提到的几个问题：**

![](https://img-blog.csdnimg.cn/2020051516520665.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

>1. 完成一次读/写操作的流程（见右上图，**Key word：轮询**）
>
>2. CPU干预的频率
>
>- 很频繁，I/O操作开始之前、完成之后需要CPU介入，并且**在等待I/O完成的过程中CPU需要不断地轮询检查**。
>
>3. 数据传送的单位 
>
>- 每次读/写**一个字**
>
>4. 数据的流向
>
>- 读操作（数据输入）：I/O设备→CPU（指的是CPU的寄存器）→内存
>
>- 写操作（数据输出）：内存→CPU→I/O
>
>  > 设备每个字的读/写都需要CPU的帮助
>
>5. 主要缺点和主要优点
>
>- 优点：实现简单。在读/写指令之后，加上实现循环检查的一系列指令即可（因此才称为“程序直接控制方式”）
>- **缺点：CPU和I/O设备只能串行工作，CPU需要一直轮询检查，长期处于“忙等”状态，CPU利用率低**

##### 5.1.3.3 [中断](https://so.csdn.net/so/search?q=中断&spm=1001.2101.3001.7020)驱动方式

- 由于`程序直接控制方式`CPU利用率低、忙等，所以提出了中断驱动方式

![](https://img-blog.csdnimg.cn/20200515165822656.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

>引入**中断机制**。由于I/O设备速度很慢，因此在CPU发出读/写命令后，可**将等待I/O的进程阻塞**，先切换到别的进程执行。当I/O完成后，控制器会向CPU发出一个中断信号，CPU**检测到中断信号后**，会保存当前进程的运行环境信息，转去执行中断处理程序处理该中断。处理中断的过程中，CPU从I/O控制器读一个字的数据传送到CPU寄存器，再写入主存。接着，**CPU恢复等待I/O的进程（或其他进程）的运行环境，然后继续执行**
>
>注意：①CPU会在每个指令周期的末尾检查中断；
>				   ②中断处理过程中需要保存、恢复进程的运行环境，这个过程是需要一定时间开销的。可见，如果中断发生的频率太高，也会降低系统性能。

**分析一下在思维导图中提到的几个问题：**

![](https://img-blog.csdnimg.cn/20200515165910621.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

>1. 完成一次读/写操作的流程（见右图，**Key word：中断**）
>
>2. CPU干预的频率
>
>- 每次I/O操作开始之前、完成之后需要CPU介入
>- **等待I/O完成的过程中CPU可以切换到别的进程执行**
>
>3. 数据传送的单位
>
>- 每次读/写**一个字**
>
>4. 数据的流向
>
>- 读操作（数据输入） : I/O设备→CPU→内存
>- 写操作（数据输出）:内存→CPU→I/O设备
>
>5. 主要缺点和主要优点
>
>- 优点：与“程序直接控制方式”相比，在“中断驱动方式”中，I/O控制器会通过中断信号主动报告I/O已完成，CPU不再需要不停地轮询。**CPU和I/O设备可并行工作**，CPU利用率得到明显提升。
>
>- 缺点：每个字在I/O设备与内存之间的传输，都需要经过CPU。而**频繁的中断处理会消耗较多的CPU时间**。

##### 5.1.3.4 [DMA](https://so.csdn.net/so/search?q=DMA&spm=1001.2101.3001.7020)方式

- 虽然`中断驱动方式解决了程序直接控制方式`的问题，但是每一次只能读/写一个字，导致CPU频繁切换，耗费了很多时间。于是人们又发明了DMA方式

![](https://img-blog.csdnimg.cn/20200515170628643.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

>与“中断驱动方式”相比，DMA方式（Direct Memory Access，**直接存储器**存取。==主要用于块设备==的I/O控制）有这样几个改进：
>
>①**数据的传送单位是“块”**。不再是一个字、一个字的传送；
>
>②**数据的流向是从设备直接放入内存，或者从内存直接到设备。**不再需要CPU作为“快递小哥”
>
>③仅在传送一个或多个数据块的开始和结束时，才需要CPU干预

> CPU指明此次要进行的操作（如：读操作），并说明要读入多少数据、数据要存放在内存的什么位置、数据在外部设备上的地址（如：在磁盘上的地址）
>
> 控制器会根据CPU提出的要求完成数据的读/写工作，整块数据的传输完成后，才向CPU发出中断信号

**DMA控制器：**

> 控制器读取块设备数据其实是一个字一个字读取的先存到DR，DR存满后，然后再转存到内存

![](https://img-blog.csdnimg.cn/20200515171317683.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

>DR (Data Register，数据寄存器）：暂存从设备到内存，或从内存到设备的数据
>
>MAR ( Memory Address Register，内存地址寄存器）：在输入时，MAR表示数据应放到内存中的什么位置；输出时MAR表示要输出的数据放在内存中的什么位置
>
>DC (Data Counter，数据计数器）：表示剩余要读/写的字节数
>
>CR (Command Register，命令/状态寄存器）：用于存放CPU发来的I/O命令，或设备的状态信息

**分析一下在思维导图中提到的几个问题：**

![](https://img-blog.csdnimg.cn/20200515171734106.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

>1.完成一次读/写操作的流程（见右图）
>
>2.CPU干预的频率
>
>- 仅在传送一个或多个数据块的开始和结束时，才需要CPU千预
>
>3.数据传送的单位
>
>- 每次读/写一个或多个块（注意：每次读写的只能是连续的多个块，且这些块读入内存后在内存中也必须是连续的）
>
>4.数据的流向（不再需要经过CPU）
>
>- 读操作（数据输入）：I/O设备→内存
>- 写操作（数据输出）:内存→I/O设备
>
>5.主要缺点和主要优点
>
>- 优点:数据传输以“块”为单位，CPU介入频率进一步降低。数据的传输不再需要先经过CPU再写入内存，数据传输效率进一步增加。CPU和I/o设备的并行性得到提升。
>
>- 缺点:CPU每发出一条I/O指令，只能读/写一个或多个连续的数据块。
>  如果要读/写多个离散存储的数据块，或者要将数据分别写到不同的内存区域时，CPU要分别发出多条I/O指令，进行多次中断处理才能完成。

##### 5.1.3.5 通道控制方式

- 通道控制方式是为了解决DMA方式连续存储的问题

![](https://img-blog.csdnimg.cn/20200515172334709.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

**分析一下在思维导图中提到的几个问题：**

![](https://img-blog.csdnimg.cn/20200515173712780.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 5.1.3.6 四种方式总结一下

![](https://img-blog.csdnimg.cn/20200515173946936.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

#### 5.1.4 I/O软件的层次结构

> （用户层软件-设备独立性软件-设备驱动程序-中断处理程序-总结回顾）

##### 5.1.4.1 I/O软件层次总览

![](https://img-blog.csdnimg.cn/20200515180717849.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 5.1.4.2 用户层软件

![](https://img-blog.csdnimg.cn/20200515181047151.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 5.1.4.3 设备独立性软件

> 设备独立性软件，又称设备无关性软件。与设备的硬件特性无关的功能几乎都在这一层实现

- 六大功能

![](https://img-blog.csdnimg.cn/20200515181513657.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

> ①向上层提供统一的调用接口（如read/write系统调用）
>
> ②设备的保护
>
> - 原理类似与文件保护。设备被看做是一种特殊的文件，不同用户对各个文件的访问权限是不一样的，同理，对设备的访问权限也不一样。
>
> ③差错处理
>
> - 设备独立性软件需要对一些设备的错误进行处理

![](https://img-blog.csdnimg.cn/20200515182003871.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

> ④设备的分配与回收
>
> ⑤数据缓冲区管理
>
> - 可以通过缓冲技术屏蔽设备之间数据交换单位大小和传输速度的差异

![](https://img-blog.csdnimg.cn/20200515182109909.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

> ⑥建立逻辑设备名到物理设备名的映射关系；根据设备类型选择调用相应的驱动程序

- 逻辑设备表—LUT

![](https://img-blog.csdnimg.cn/20200515182429409.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

>操作系统系统可以采用两种方式管理**逻辑设备表（LUT）**：
>
>- 第一种方式，**整个系统只设置一张LUT**，这就意味着所有用户不能使用相同的逻辑设备名，因此这种方式只适用于单用户操作系统
>- 第二种方式，**为每个用户设置一张LUT**，各个用户使用的逻辑设备名可以重复，适用于多用户操作系统。系统会在用户登录时为其建立一个用户管理进程，而LUT就存放在用户管理进程的PCB中。

- 为什么不同的设备需要不同的驱动程序呢？

![](https://img-blog.csdnimg.cn/20200515182624559.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

> 各式各样的设备，外形不同，其内部的电子部件（I/O控制器）也有可能不同

**举几个假设的例子：**

![](https://img-blog.csdnimg.cn/20200515182716188.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200515182751639.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200515183808638.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

> ==不同设备的内部硬件特性也不同==，这些特性只有厂家才知道，因此厂家须提供与设备相对应的驱动程序，CPU执行驱动程序的指令序列，来完成设置设备寄存器，检查设备状态等工作

##### 5.1.4.4 设备驱动程序

> 主要负责对硬件设备的具体控制，将上层发出的一系列命令（如read/write）转化成特定设备“能听得懂”的一系列操作。包括设置设备寄存器；检查设备状态等

![](https://img-blog.csdnimg.cn/20200515184018765.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

> 硬件：不同的I/O设备有不同的硬件特性，具体细节只有设备的厂家才知道。因此厂家需要根据设备的硬件特性设计并提供相应的驱动程序

##### 5.1.4.5 [中断](https://so.csdn.net/so/search?q=中断&spm=1001.2101.3001.7020)处理程序

![](https://img-blog.csdnimg.cn/20200515184602693.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200515184322628.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 5.1.4.6 总结回顾

![](https://img-blog.csdnimg.cn/20200515184834582.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

> 理解并记住I/O软件**各个层次之间的顺序**，要能够推理判断某个处理应该是在哪个层次完成的（最常考的是设备独立性软件、设备驱动程序这两层。只需理解一个特点即可：**直接涉及到硬件具体细节、且与中断无关的操作肯定是在设备驱动程序层完成的；没有涉及硬件的、对各种设备都需要进行的管理工作都是在设备独立性软件层完成的**）

### 5.2 I/O核心子系统

#### 5.2.1 内核的I/O核心子系统及功能

##### 5.2.1.1 I/O核心子系统以及功能

>设备独立性软件、设备驱动程序、中断处理程序

![](https://img-blog.csdnimg.cn/20200515185345674.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 5.2.1.2 这些功能在哪个层次实现？

>用户层软件：假脱机技术（SPOOLing技术)
>
>设备独立性软件：I/O调度、设备保护、设备分配与回收、缓冲区管理（即缓冲与高速缓存）

###### 假[脱机](https://so.csdn.net/so/search?q=脱机&spm=1001.2101.3001.7020)技术

![](https://img-blog.csdnimg.cn/20200515220320212.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

###### I/O调度

![](https://img-blog.csdnimg.cn/20200515220401866.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

###### 设备保护

![](https://img-blog.csdnimg.cn/20200515220644868.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

>操作系统需要实现**文件保护功能**，不同的用户对各个文件有不同的访问权限（如：只读、读和写等）。
>
>在UNIX系统中，**设备被看做是一种特殊的文件**，每个设备也会有对应的FCB。当用户请求访问某个设备时，系统根据FCB中记录的信息来判断该用户是否有相应的访问权限，以此实现“设备保护”的功能。（参考“文件保护”小节）

#### 5.2.2 I/O设备假脱机技术(SPOOLing)

##### 5.2.2.1 总览

![](https://img-blog.csdnimg.cn/20200515221735109.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 5.2.2.2 什么是[脱机](https://so.csdn.net/so/search?q=脱机&spm=1001.2101.3001.7020)技术？

**这里温习一下手工操作阶段：**

![](https://img-blog.csdnimg.cn/20200515222024552.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

> 手工操作阶段：主机直接从I/O设备获得数据，由于设备速度慢，主机速度很快。人机速度矛盾明显，主机要浪费很多时间来等待设备

- 因为手工阶段的速度慢问题，引入了脱机技术

  > 批处理阶段引入了**脱机输入/输出技术**（用磁带完成）：引入脱机技术后，缓解了CPU与慢速I/O设备的速度矛盾。另一方面，即使CPU在忙碌，也可以提前将数据输入到磁带；即使慢速的输出设备正在忙碌，也可以提前将数据输出到磁带。

![](https://img-blog.csdnimg.cn/20200515222353310.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

>在外围控制机的控制下，慢速输入设备的数据先被输入到更快速的磁带上。之后主机可以从快速的磁带上读入数据，从而缓解
>了速度矛盾
>
>Tips：为什么称为“脱机”——脱离主机的控制进行的输入/输出操作

##### 5.2.2.3 假脱机技术

- 在脱机技术的基础上人们发明了更好的假脱机技术

###### 输入井和输出井

> “假脱机技术”，又称“SPOOLing 技术”是用软件的方式模拟脱机技术。SPOOLing系统的组成如下：
>
> 在磁盘上开辟出两个存储区域——“输入井”和“输出井”
>
> - “输入井”模拟脱机输入时的磁带，用于收容I/O设备输入的数据
>
> - ”输出井“模拟脱机输出时的磁带，用于收容用户进程输出的数据

![](https://img-blog.csdnimg.cn/20200515222652188.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200515222741863.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

###### 输入进程与输出进程

> 要实现SPOOLing 技术，**必须要有多道程序技术的支持**。系统会建立“输入进程”和“输出进程”。
>
> ”输入进程“模拟脱机输入时的外围控制机
>
> “输出进程”模拟脱机输出时的外围控制机

![](https://img-blog.csdnimg.cn/20200515222928651.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200515223017634.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

###### 输入输出缓冲区

![](https://img-blog.csdnimg.cn/20200515223130647.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

>在输入进程的控制下，“输入缓冲区”用于暂存从输入设备输入的数据，之后再转存到输入井中
>
>在输出进程的控制下，“输出缓冲区”用于暂存从输出井送来的数据，之后再传送到输出设备上
>
>> 注意，输入缓冲区和输出缓冲区是在内存中的缓冲区

###### 共享打印机原理分析—假脱机技术的一种应用

**先了解一下独占和共享设备，以此引出假脱机技术如何实现对独占设备的共享：**

> 独占式设备――**只允许各个进程串行使用的设备**。一段时间内只能满足一个进程的请求。
>
> 共享设备――**允许多个进程“同时”使用的设备**（宏观上同时使用，微观上可能是交替使用）。可以同时满足多个进程的使用请求。

![](https://img-blog.csdnimg.cn/20200515223408863.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

>打印机是种“独占式设备”，但是可以用SPOOLing技术改造成“共享设备”
>
>独占式设备的例子：若进程1正在使用打印机，则进程2请求使用打印机时必然阻塞等待

![](https://img-blog.csdnimg.cn/20200515224221392.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

>当多个用户进程提出输出打印的请求时，系统会答应它们的请求，但是并不是真正把打印机分配给他们，而是由假脱机管理进程为每个进程做两件事：
>
>（1）在磁盘输出井中为进程申请一个==空闲缓冲区==（也就是说，这个缓冲区是在磁盘上的），并将要打印的==数据==送入其中；
>
>（2）为用户进程申请一张空白的==打印请求表==，并将用户的打印请求填入表中（其实就是用来说明用户的打印数据存放位置等信息的），再将该表==挂到假脱机文件队列上==。
>
>==当打印机空闲时==，输出进程会从==文件队列==的队头==取出一张打印请求表==，并根据表中的要求将要打印的数据从==输出井==传送到==输出缓冲区==，再==输出到打印机进行打印==。用这种方式可依次处理完全部的打印任务

- 打印请求完成后，请求表从打印队列删除，执行后续队列的打印任务

![](https://img-blog.csdnimg.cn/20200515224600416.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

>虽然系统中只有一个台打印机，但每个进程提出打印请求时，系统都会为在输出井中为其分配一个存储区（相当于分配了一个逻辑设备），使每个用户进程都觉得自己在独占一台打印机，从而实现对打印机的共享。
>
>SPOOLing技术可以把一台物理设备**虚拟**成逻辑上的多台设备，**可将独占式设备改造成共享设备**。

#### 5.2.3 I/O设备的分配与回收（DCT-COCT-CHCT-SDT）

##### 5.2.3.1 总览

![](https://img-blog.csdnimg.cn/20200515225630588.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 5.2.3.2 设备分配时应该考虑的因素

###### 设备的固有属性

> 设备的固有属性可分为三种：独占设备、共享设备、虚拟设备

![](https://img-blog.csdnimg.cn/2020051523091869.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

>**独占设备**——一个时段只能分配给一个进程（如打印机）
>
>**共享设备**――可同时分配给多个进程使用（如磁盘），各进程往往是宏观上同时共享使用设备，而微观上交替使用
>
>**虚拟设备**――采用SPOOLing技术将独占设备改造成虚拟的共享设备，可同时分配给多个进程使用（如采用SPOOLing技术实现的共享打印机）

###### 设备的分配算法

![](https://img-blog.csdnimg.cn/2020051523102064.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

###### 设备分配中的安全性

![](https://img-blog.csdnimg.cn/20200515232557269.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

>**安全分配方式**：为进程分配一个设备后就将进程阻塞，本次I/O完成后才将进程唤醒（eg：考虑进程请求打印机打印输出的例子）
>
>- 一个时段内每个进程只能使用一个设备
>
>- 优点：破坏了“请求和保持”条件，不会死锁
>
>- 缺点：对于一个进程来说，CPU和I/O设备只能串行工作
>
>**不安全分配方式**：进程发出I/O请求后，系统为其分配/O设备，进程可继续执行，之后还可以发出新的I/O请求。只有某个l/O请求得不到满足时才将进程阻塞。
>
>- 一个进程可以同时使用多个设备
>
>- 优点：进程的计算任务和I/O任务可以并行处理，使进程迅速推进
>- 缺点：有可能发生死锁（死锁避免、死锁的检测和解除）

##### 5.2.3.3 静态分配与动态分配

>静态分配：进程运行前为其分配全部所需资源，运行结束后归还资源
>
>- 破坏了“请求和保持”条件，不会发生死锁
>
>动态分配：进程运行过程中动态申请设备资源

![](https://img-blog.csdnimg.cn/20200515232722540.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 5.2.3.4 设备分配管理中的数据结构

**设备、控制器、通道之间的关系：**

> 一个通道可控制多个设备控制器，每个设备控制器可控制多个设备

![](https://img-blog.csdnimg.cn/20200515233622439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

###### 设备控制表—DCT

> 系统为每个设备配置一张DCT，用于记录设备情况

![](https://img-blog.csdnimg.cn/20200515234002740.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

>设备类型——如：打印机/扫描仪/键盘
>
>设备标识符——即物理设备名，系统中的每个设备的物理设备名唯一
>
>设备状态——忙碌/空闲/故障...
>
>指向控制器表的指针——每个设备由一个控制器控制，该指针可找到相应控制番的信恳
>
>重复执行次数或时间——当重复执行多次l/O操作后仍不成功，才认为此次l/O失败
>
>设备队列的队首指针——指向正在等待该设备的进程队列（由进程PCB组成队列）
>
>注：“进程管理”章节中曾经提到过“系统会根据阻塞原因不同，将进程PCB挂到不同的阻塞队列中”

###### 控制器控制表—COCT

> 每个设备控制器都会对应一张COCT。操作系统根据COCT的信息对控制器进行操作和管理

![](https://img-blog.csdnimg.cn/20200515234546353.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

>控制器标识符——各个控制器的唯一ID
>
>控制器状态——忙碌/空闲/故障...
>
>指向通道表的指针——每个控制器由一个通道控制，该指针可找到相应通道的信息
>
>控制器队列的队首指针——
>
>控制器队列的队尾指针——指向正在等待该控制器的进程队列（由进程PCB组成队列)

###### [通道](https://so.csdn.net/so/search?q=通道&spm=1001.2101.3001.7020)控制表—CHCT

> 每个通道都会对应一张CHCT。操作系统根据CHCT的信息对通道进行操作和管理

![](https://img-blog.csdnimg.cn/20200515234644297.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

>通道标识符——各个通道的唯一ID
>
>通道状态——忙碌/空闲/故障...
>
>与通道连接的控制器表首址——可通过该指针找到该通道管理的所有控制器相关信息(COCT)
>
>通道队列的队首指针——指向正在等待该通道的进程队列（由进程PCB组成队列)
>
>通道队列的队尾指针——

###### 系统设备表—SDT

> 记录了**系统中全部设备**的情况，每个设备对应一个表目

![](https://img-blog.csdnimg.cn/2020051523492184.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

>设备类型——如：打印机/扫描仪/键盘
>
>设备标识符——即物理设备名
>
>==DCT（设备控制表）==
>
>驱动程序入口

##### 5.2.3.5 设备分配的步骤

> ①根据进程请求的**物理设备名**查找SDT（注：物理设备名是进程请求分配设备时提供的参数）

![](https://img-blog.csdnimg.cn/20200522095412270.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

> ②根据SDT找到DCT，若**设备**忙碌则将进程PCB挂到**设备等待队列**中，不忙碌则将设备分配给进程

![](https://img-blog.csdnimg.cn/20200522095426160.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

> ③根据DCT找到COCT，若**控制器**忙碌则将进程PCB挂到**控制器等待队列**中，不忙碌则将**控制器**分配给进程

![](https://img-blog.csdnimg.cn/20200522095858360.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

> ④根据COCT找到CHCT，若**通道**忙碌则将进程PCB挂到**通道等待队列**中，不忙碌则将**通道**分配给进程

![](https://img-blog.csdnimg.cn/20200522095945382.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

> 注：只有设备、控制器、通道三者都分配成功时，这次设备分配才算成功，之后便可启动I/O设备进行数据传送

###### 设备分配的改进步骤

![](https://img-blog.csdnimg.cn/20200522100203731.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

>缺点:
>
>①用户编程时必须使用“物理设备名”，底层细节对用户不透明，不方便编程
>
>②若换了一个物理设备，则程序无法运行
>
>③若进程请求的物理设备正在忙碌，则即使系统中还有同类型的设备，进程也必须阻塞等待
>
>**改进方法**：建立逻辑设备名与物理设备名的映射机制，用户编程时只需提供逻辑设备名

![](https://img-blog.csdnimg.cn/20200522100741393.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

>①根据进程请求的逻辑设备名查找SDT（注：用户编程时提供的逻辑设备名其实就是“设备类型”）
>
>②查找SDT，找到用户进程指定类型的、并且空闲的设备，将其分配给该进程。操作系统在逻辑设备表（LUT）中新增一个表项
>
>③根据DCT找到COCT，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程
>
>④根据COCT找到CHCT，若通道忙碌则将进程PCB挂到通道等待队列中，不忙碌则将通道分配给进程

![](https://img-blog.csdnimg.cn/2020052210093782.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

>**逻辑设备表（LUT）建立了逻辑设备名与物理设备名之间的映射关系**
>
>某用户进程第一次使用设备时使用逻辑设备名向操作系统发出请求，操作系统根据用户进程指定的设备类型（逻辑设备名）查找系统设备表，找到一个空闲设备分配给进程，并在LUT中增加相应表项
>
>**如果之后用户进程再次通过相同的逻辑设备名请求使用设备，则操作系统通过LUT表即可知道用户进程实际要使用的是哪个物理设备了，并且也能知道该设备的驱动程序入口地址**

>逻辑设备表的设置问题：
>
>整个系统只有一张LUT：各用户所用的**逻辑设备名不允许重复**，适用于单用户操作系统
>
>每个用户一张LUT：**不同用户的逻辑设备名可重复**，适用于多用户操作系统

#### 5.2.4 缓冲区管理（单缓冲-双缓冲-循环缓冲-缓冲池）

##### 5.2.4.1 总览

![](https://img-blog.csdnimg.cn/20200522102540212.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 5.2.4.2 什么是缓冲区？有什么作用？

> - 缓解CPU与设备的速度矛盾
> - 减少对CPU的中断频率
> - 解决数据粒度不匹配的问题（如：输出进程每次可以生成一块数据，但I/O设备每次只能输出一个字符）
> - 提高CPU与I/O设备之间的并行性

![](https://img-blog.csdnimg.cn/202005221031357.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

>CPU可以把要输出的数据快速地放入缓冲区，之后就可以做别的事，慢速的I/O设备可以慢慢从缓冲区取走数据，数据输入时类似
>
>如果是字符型设备则每输出完个字符就要向CPU发送一次中断信号

##### 5.2.4.3 单缓冲

>假设某用户进程请求某种块设备读入若干块的数据。若采用**单缓冲**的策略，操作系统会**在主存中为其分配一个缓冲区**（若题目中没有特别说明，一个缓冲区的大小就是一个块）
>
>**注意：当缓冲区数据非空时，不能往缓冲区冲入数据，只能从缓冲区把数据传出;当缓冲区为空时，可以往缓冲区冲入数据，但必须把缓冲区充满以后，才能从缓冲区把数据传出。**

![](https://img-blog.csdnimg.cn/20200522103814186.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

> 用户进程的内存空间中，会分出一片工作区来接受输入/输出数据（一般也默认工作区大小与缓冲区相同）

**T>C时的例子：**

![](https://img-blog.csdnimg.cn/20200522104336785.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200522104442809.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200522104531115.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

**T<C时：**

![](https://img-blog.csdnimg.cn/20200522104759580.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)



##### 5.2.4.4 双缓冲

**T>C+M时：**

![](https://img-blog.csdnimg.cn/20200522105306536.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

**T<C+M时：**

![](https://img-blog.csdnimg.cn/20200522105803750.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200522110019682.png)

##### 5.2.4.5 单缓冲和双缓冲通信时的区别

![](https://img-blog.csdnimg.cn/20200522110501685.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200522110633448.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 5.2.4.6 循环缓冲区

![](https://img-blog.csdnimg.cn/20200522110906592.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

##### 5.2.4.7 缓冲池

![](https://img-blog.csdnimg.cn/20200522111159604.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200522111222254.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200522111342591.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200522111517161.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

![](https://img-blog.csdnimg.cn/20200522111623908.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

